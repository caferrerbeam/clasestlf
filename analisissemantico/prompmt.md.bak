# ğŸ“˜ PresentaciÃ³n: Analizador SemÃ¡ntico - Del AST al Significado

## PÃ¡gina 1: Portada
- TÃ­tulo: *"Analizador SemÃ¡ntico: Dando Significado al CÃ³digo"*
- SubtÃ­tulo: "De Ãrboles SintÃ¡cticos a CÃ³digo con Sentido"
- Curso: Compiladores y TeorÃ­a de Lenguajes
- Universidad EAM

---

## PÃ¡gina 2: Arquitectura del Compilador - UbicaciÃ³n del AnÃ¡lisis SemÃ¡ntico

### **Â¿DÃ³nde estamos en el proceso de compilaciÃ³n?**

```mermaid
graph TB
    A[CÃ³digo Fuente] --> B[ğŸ“ Analizador LÃ©xico]
    B --> C[Tokens]
    C --> D[ğŸŒ³ Analizador SintÃ¡ctico]
    D --> E[AST - Ãrbol de Sintaxis]
    E --> F[ğŸ§  ANALIZADOR SEMÃNTICO]
    F --> G[AST Anotado + Tabla de SÃ­mbolos]
    G --> H[âš™ï¸ Generador de CÃ³digo]
    H --> I[CÃ³digo Objeto]

    style F fill:#ff6b6b,stroke:#c92a2a,stroke-width:4px
    style E fill:#4ecdc4,stroke:#45b7aa
    style G fill:#95e1d3,stroke:#45b7aa
```

### **Ejemplo concreto del flujo:**

**CÃ³digo fuente:**
```java
int x = 5;
x = 'a';
```

**Fase 1 - Analizador LÃ©xico:**
```
Entrada: "int x = 5; x = 'a';"
Salida: [INT, ID("x"), ASSIGN, NUM(5), SEMICOLON, ID("x"), ASSIGN, CHAR('a'), SEMICOLON]
Resultado: âœ“ Ã‰XITO
```

**Fase 2 - Analizador SintÃ¡ctico:**
```
Entrada: [INT, ID("x"), ASSIGN, NUM(5), SEMICOLON, ID("x"), ASSIGN, CHAR('a'), SEMICOLON]
Salida: AST
    ProgramNode
    â”œâ”€â”€ VariableDeclarationNode(type=int, name="x", value=5)
    â””â”€â”€ AssignmentNode(name="x", value='a')
Resultado: âœ“ Ã‰XITO (sintÃ¡cticamente vÃ¡lido)
```

**Fase 3 - Analizador SemÃ¡ntico:**
```
Entrada: AST del paso anterior
Proceso:
  1. Declara x como int â†’ OK, agregar a tabla de sÃ­mbolos
  2. Asignar 'a' (char) a x (int) â†’ âœ— ERROR

Error: LÃ­nea 2: No se puede asignar tipo 'char' a variable de tipo 'int'
Resultado: âœ— FALLO SEMÃNTICO
```

### **Pregunta clave para reflexionar:**
Â¿Por quÃ© el cÃ³digo pasa el anÃ¡lisis sintÃ¡ctico pero falla en el semÃ¡ntico?

**Respuesta:** Porque sintÃ¡cticamente `x = 'a'` sigue las reglas gramaticales (variable = expresiÃ³n), pero semÃ¡nticamente no tiene sentido asignar un char a una variable int.

**El anÃ¡lisis semÃ¡ntico es el "detector de sentido comÃºn" del compilador.**

---

## PÃ¡gina 3: Â¿QuÃ© Hace el Analizador SemÃ¡ntico?

### **Responsabilidades principales:**

#### **1. ğŸ” VerificaciÃ³n de Tipos**

**Â¿QuÃ© significa?** Verificar que las operaciones se hacen con tipos compatibles.

**Ejemplos concretos:**

```java
// VÃLIDO: Los tipos coinciden
int x = 5;        // int = int âœ“
double y = 3.14;  // double = double âœ“

// INVÃLIDO: Los tipos son incompatibles
int x = "hola";   // int = String âœ—
boolean b = 42;   // boolean = int âœ—
```

**Â¿Por quÃ© es importante?** Sin verificaciÃ³n de tipos, podrÃ­as intentar sumar un nÃºmero con un texto, lo cual no tiene sentido matemÃ¡tico.

#### **2. ğŸ“‹ GestiÃ³n de la Tabla de SÃ­mbolos**

**Â¿QuÃ© significa?** Llevar un registro de todas las variables declaradas y su informaciÃ³n.

**Ejemplo paso a paso:**

```java
// LÃ­nea 1:
int x = 5;
// El analizador semÃ¡ntico pregunta:
// - Â¿"x" ya existe? No â†’ OK, crear entrada
// - Â¿El tipo es vÃ¡lido? SÃ­, "int" es un tipo conocido
// - Â¿La inicializaciÃ³n es correcta? SÃ­, 5 es un int
// AcciÃ³n: Agregar "x" (tipo: int, valor: 5) a la tabla

// LÃ­nea 2:
int x = 10;
// El analizador semÃ¡ntico pregunta:
// - Â¿"x" ya existe? SÃ â†’ âœ— ERROR!
// Error: Variable 'x' ya fue declarada en lÃ­nea 1
```

#### **3. ğŸ¯ VerificaciÃ³n de Contexto**

**Â¿QuÃ© significa?** Verificar que las instrucciones se usan en el contexto correcto.

**Ejemplo concreto:**

```java
// CONTEXTO INCORRECTO:
void foo() {
    break;  // âœ— ERROR: break debe estar DENTRO de un loop
}

// CONTEXTO CORRECTO:
void foo() {
    while (true) {
        break;  // âœ“ OK: break estÃ¡ dentro de un loop
    }
}
```

**Pregunta:** Â¿Por quÃ© `break` fuera de un loop es un error?

**Respuesta:** Porque `break` significa "salir del loop actual". Si no hay loop, Â¿de quÃ© salimos?

#### **4. ğŸ”„ ResoluciÃ³n de Nombres**

**Â¿QuÃ© significa?** Identificar a cuÃ¡l declaraciÃ³n se refiere cada uso de variable.

**Ejemplo con scopes anidados:**

```java
int x = 10;  // x global

void foo() {
    int x = 20;  // x local (diferente del global)

    // Cuando veo "x" aquÃ­, Â¿a cuÃ¡l me refiero?
    System.out.println(x);  // Â¿10 o 20?
}
```

**Respuesta:** Se refiere a `x = 20` (la mÃ¡s cercana en el scope actual).

**Regla:** Siempre se usa la variable del scope mÃ¡s interno.

### **Resumen visual:**

```
Input del Analizador SemÃ¡ntico:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AST (sintÃ¡cticamente    â”‚
â”‚ correcto)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Output del Analizador SemÃ¡ntico:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ“ AST anotado con tipos â”‚
â”‚ âœ“ Tabla de sÃ­mbolos     â”‚
â”‚ âœ“ Lista de errores      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## PÃ¡gina 4: SintÃ¡ctico vs SemÃ¡ntico - Â¿CuÃ¡l es la Diferencia?

### **AnalogÃ­a con lenguaje natural:**

#### **AnÃ¡lisis SintÃ¡ctico (forma):**

```
âœ“ CORRECTO (buena gramÃ¡tica):
   "El perro come manzanas"
   Sujeto + Verbo + Objeto = VÃLIDO

âœ— INCORRECTO (mala gramÃ¡tica):
   "Perro el manzanas come"
   Sin estructura gramatical = INVÃLIDO
```

#### **AnÃ¡lisis SemÃ¡ntico (significado):**

```
âœ“ TIENE SENTIDO:
   "El perro come manzanas"
   Los perros pueden comer manzanas en la realidad

âœ— NO TIENE SENTIDO (aunque sea gramaticalmente correcto):
   "Las manzanas comen perros"
   Gramaticalmente perfecto, pero absurdo en la realidad
```

### **En programaciÃ³n:**

#### **Caso 1: Incompatibilidad de tipos**

**SintÃ¡cticamente correcto, semÃ¡nticamente incorrecto:**

```java
int x = 5;
x = "hola";
```

**AnÃ¡lisis sintÃ¡ctico dice:**
```
âœ“ LÃ­nea 1: DeclaraciÃ³n vÃ¡lida (tipo + nombre + = + valor + ;)
âœ“ LÃ­nea 2: AsignaciÃ³n vÃ¡lida (nombre + = + valor + ;)
ConclusiÃ³n: SINTAXIS CORRECTA
```

**AnÃ¡lisis semÃ¡ntico dice:**
```
âœ“ LÃ­nea 1: OK
  - Declarar x como int
  - Inicializar con 5 (int)
  - Agregar x:int a la tabla de sÃ­mbolos

âœ— LÃ­nea 2: ERROR
  - x es int (de la lÃ­nea 1)
  - "hola" es String
  - int â‰  String
  - Error: No se puede asignar String a int
```

#### **Caso 2: NÃºmero incorrecto de argumentos**

**SintÃ¡cticamente correcto, semÃ¡nticamente incorrecto:**

```java
int suma(int a, int b) {
    return a + b;
}

int resultado = suma(5);  // Solo 1 argumento, se necesitan 2
```

**AnÃ¡lisis sintÃ¡ctico dice:**
```
âœ“ DeclaraciÃ³n de funciÃ³n: OK
âœ“ Llamada a funciÃ³n: OK (nombre + parÃ©ntesis + argumentos)
ConclusiÃ³n: SINTAXIS CORRECTA
```

**AnÃ¡lisis semÃ¡ntico dice:**
```
âœ“ FunciÃ³n 'suma' declarada correctamente
  - Requiere 2 parÃ¡metros: int, int
  - Retorna: int

âœ— Llamada a 'suma' incorrecta
  - Se proporcionÃ³ 1 argumento
  - Se requieren 2 argumentos
  - Error: suma() espera 2 argumentos, se recibieron 1
```

### **Tabla comparativa:**

| Aspecto | SintÃ¡ctico | SemÃ¡ntico | Ejemplo |
|---------|-----------|-----------|---------|
| **Â¿QuÃ© verifica?** | La forma/estructura | El significado/sentido | |
| **Detecta** | ParÃ©ntesis faltantes, palabras mal ordenadas | Tipos incompatibles, variables no declaradas | |
| **Ejemplo vÃ¡lido** | `int x = 5;` | `int x = 5;` | âœ“ VÃ¡lido en ambos |
| **Ejemplo invÃ¡lido sintÃ¡ctico** | `int x = ;` | (no llega a semÃ¡ntico) | âœ— Falta valor |
| **Ejemplo invÃ¡lido semÃ¡ntico** | `int x = "hola";` | `int x = "hola";` | âœ“ Sintaxis OK, âœ— SemÃ¡ntica FAIL |

### **Regla de oro:**

```
El anÃ¡lisis sintÃ¡ctico verifica la FORMA
El anÃ¡lisis semÃ¡ntico verifica el SIGNIFICADO

Ambos deben pasar para que el cÃ³digo sea vÃ¡lido.
```

### **Pregunta para reflexionar:**

Â¿Este cÃ³digo pasa el anÃ¡lisis sintÃ¡ctico? Â¿Y el semÃ¡ntico?

```java
int suma(int a, int b) {
    return a + b;
}

int x = suma(5, "hola");
```

**Respuesta:**
- **SintÃ¡ctico:** âœ“ SÃ (estructura correcta)
- **SemÃ¡ntico:** âœ— NO (el segundo argumento debe ser int, no String)

---

## PÃ¡gina 5: Tabla de SÃ­mbolos - El CorazÃ³n del AnÃ¡lisis SemÃ¡ntico

### **Â¿QuÃ© es la Tabla de SÃ­mbolos?**

Es como una **base de datos** que almacena informaciÃ³n sobre TODOS los identificadores (variables, funciones, clases) que aparecen en tu programa.

**AnalogÃ­a:** Piensa en ella como una agenda telefÃ³nica. Cada contacto (variable) tiene:
- Nombre (identificador)
- Tipo (int, double, etc.)
- InformaciÃ³n adicional (dÃ³nde fue declarado, su valor, etc.)

```mermaid
graph LR
    A[Identificador: x] --> B[InformaciÃ³n Completa]
    B --> C[Tipo: int]
    B --> D[Scope: global]
    B --> E[Valor Inicial: 5]
    B --> F[PosiciÃ³n en Memoria: 0x1000]
    B --> G[LÃ­nea de DeclaraciÃ³n: 1]
```

### **Ejemplo paso a paso: Construyendo la tabla**

Analicemos este cÃ³digo lÃ­nea por lÃ­nea:

```java
int x = 5;
double y = 3.14;
boolean flag = true;
```

#### **Paso 1: Analizar lÃ­nea 1**

```
CÃ³digo: int x = 5;

Preguntas del analizador:
1. Â¿"x" ya existe en la tabla? â†’ No
2. Â¿"int" es un tipo vÃ¡lido? â†’ SÃ­
3. Â¿5 es compatible con int? â†’ SÃ­

AcciÃ³n: Insertar en la tabla de sÃ­mbolos
```

**Tabla de SÃ­mbolos despuÃ©s de lÃ­nea 1:**

| Nombre | Tipo | Scope  | Valor Inicial | LÃ­nea |
|--------|------|--------|---------------|-------|
| x      | int  | global | 5             | 1     |

#### **Paso 2: Analizar lÃ­nea 2**

```
CÃ³digo: double y = 3.14;

Preguntas del analizador:
1. Â¿"y" ya existe en la tabla? â†’ No
2. Â¿"double" es un tipo vÃ¡lido? â†’ SÃ­
3. Â¿3.14 es compatible con double? â†’ SÃ­

AcciÃ³n: Insertar en la tabla de sÃ­mbolos
```

**Tabla de SÃ­mbolos despuÃ©s de lÃ­nea 2:**

| Nombre | Tipo   | Scope  | Valor Inicial | LÃ­nea |
|--------|--------|--------|---------------|-------|
| x      | int    | global | 5             | 1     |
| y      | double | global | 3.14          | 2     |

#### **Paso 3: Analizar lÃ­nea 3**

```
CÃ³digo: boolean flag = true;

Preguntas del analizador:
1. Â¿"flag" ya existe en la tabla? â†’ No
2. Â¿"boolean" es un tipo vÃ¡lido? â†’ SÃ­
3. Â¿true es compatible con boolean? â†’ SÃ­

AcciÃ³n: Insertar en la tabla de sÃ­mbolos
```

**Tabla de SÃ­mbolos FINAL:**

| Nombre | Tipo    | Scope  | Valor Inicial | LÃ­nea |
|--------|---------|--------|---------------|-------|
| x      | int     | global | 5             | 1     |
| y      | double  | global | 3.14          | 2     |
| flag   | boolean | global | true          | 3     |

### **Â¿QuÃ© pasa si intentamos declarar una variable duplicada?**

```java
int x = 5;    // LÃ­nea 1
int x = 10;   // LÃ­nea 2
```

**Proceso:**

```
LÃ­nea 1: int x = 5;
  1. Â¿"x" existe? â†’ No
  2. Insertar x:int en tabla â†’ OK

LÃ­nea 2: int x = 10;
  1. Â¿"x" existe? â†’ SÃ (ya estÃ¡ en la lÃ­nea 1)
  2. âœ— ERROR!

Error semÃ¡ntico en lÃ­nea 2:
  Variable 'x' ya fue declarada en lÃ­nea 1
```

### **Operaciones de la Tabla de SÃ­mbolos:**

#### **1. `insert(symbol)` - Agregar sÃ­mbolo**

```
Uso: Cuando encontramos una declaraciÃ³n de variable
Ejemplo: int x = 5;
AcciÃ³n: Agregar entrada para "x" en la tabla
```

#### **2. `lookup(name)` - Buscar sÃ­mbolo**

```
Uso: Cuando encontramos un uso de variable
Ejemplo: y = x + 1;
AcciÃ³n: Buscar "x" en la tabla para saber su tipo
```

#### **3. `update(name, info)` - Actualizar informaciÃ³n**

```
Uso: Cuando cambiamos alguna propiedad
Ejemplo: Actualizar el valor de una variable
```

#### **4. `delete(name)` - Eliminar sÃ­mbolo**

```
Uso: Cuando salimos de un scope y las variables locales ya no existen
Ejemplo: Al terminar un bloque { }
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© contiene la tabla de sÃ­mbolos despuÃ©s de este cÃ³digo?

```java
int a = 10;
double b = 20.5;
int a = 30;
```

**Respuesta:**

```
LÃ­nea 1: OK, tabla = {a:int}
LÃ­nea 2: OK, tabla = {a:int, b:double}
LÃ­nea 3: âœ— ERROR - "a" ya existe

La tabla se queda con: {a:int (10), b:double (20.5)}
El error impide que se agregue el segundo "a"
```

---

## PÃ¡gina 6: PatrÃ³n Visitor - Recorriendo el AST de Forma Elegante

### **Â¿QuÃ© es el patrÃ³n Visitor?**

El patrÃ³n Visitor es una tÃ©cnica para **separar las operaciones de las estructuras de datos** sobre las que operan.

**AnalogÃ­a del mundo real:** Un inspector de edificios

Imagina un edificio con diferentes tipos de habitaciones:
- ğŸ  HabitaciÃ³n â†’ Cocina, Dormitorio, BaÃ±o, Sala
- ğŸ‘· Inspector â†’ Inspector de Seguridad, Inspector ElÃ©ctrico, Inspector Sanitario

**Sin Visitor (MALO):**
Cada habitaciÃ³n tiene que saber quÃ© hacer con cada tipo de inspector:

```java
class Cocina {
    void inspeccionSeguridad() { ... }
    void inspeccionElectrica() { ... }
    void inspeccionSanitaria() { ... }
    // Â¿Nuevo inspector? â†’ Modificar TODAS las habitaciones âŒ
}
```

**Con Visitor (BUENO):**
Las habitaciones solo dicen "acepto inspecciÃ³n", el inspector decide quÃ© hacer:

```java
class Cocina {
    void aceptar(Inspector inspector) {
        inspector.inspeccionarCocina(this); // Delegar al inspector
    }
}
```

### **Â¿Por quÃ© necesitamos Visitor en el anÃ¡lisis semÃ¡ntico?**

En un compilador, el AST (Ãrbol de Sintaxis Abstracta) tiene **muchos tipos de nodos**:
- `VariableNode`, `BinaryOpNode`, `FunctionNode`, `IfNode`, etc.

Y necesitamos hacer **mÃºltiples operaciones** sobre el AST:
- âœ… VerificaciÃ³n de tipos
- âœ… VerificaciÃ³n semÃ¡ntica
- âœ… GeneraciÃ³n de cÃ³digo
- âœ… OptimizaciÃ³n
- âœ… Pretty printing

**Problema sin Visitor:**

```java
class BinaryOpNode {
    void typeCheck() { ... }           // OperaciÃ³n 1
    void generateCode() { ... }        // OperaciÃ³n 2
    void optimize() { ... }            // OperaciÃ³n 3
    void prettyPrint() { ... }         // OperaciÃ³n 4
    // Â¿Nueva operaciÃ³n? â†’ Modificar TODAS las clases de nodos âŒ
}
```

âŒ **Problemas:**
1. Si agregamos una nueva operaciÃ³n, debemos modificar **todas las clases de nodos**
2. Mezcla responsabilidades: cada nodo tiene cÃ³digo de tipos, cÃ³digo de generaciÃ³n, etc.
3. DifÃ­cil de mantener

**SoluciÃ³n con Visitor:**

```java
class BinaryOpNode {
    <T> T accept(ASTVisitor<T> visitor) {
        return visitor.visitBinaryOp(this);
    }
}

// Nueva operaciÃ³n = Nueva clase Visitor
class TypeCheckVisitor implements ASTVisitor<Type> { ... }
class CodeGenVisitor implements ASTVisitor<String> { ... }
class OptimizerVisitor implements ASTVisitor<ASTNode> { ... }
```

âœ… **Ventajas:**
1. Nueva operaciÃ³n = Solo crear nueva clase Visitor
2. No modificamos las clases de nodos
3. Cada operaciÃ³n estÃ¡ en su propia clase (separaciÃ³n de responsabilidades)

### **CÃ³mo funciona el patrÃ³n Visitor: Paso a paso**

#### **Paso 1: Definir la interfaz Visitor**

```java
interface ASTVisitor<T> {
    T visitBinaryOp(BinaryOpNode node);
    T visitVariable(VariableNode node);
    T visitNumber(NumberNode node);
    T visitFunction(FunctionNode node);
    // Un mÃ©todo por cada tipo de nodo
}
```

#### **Paso 2: Cada nodo tiene un mÃ©todo `accept()`**

```java
class BinaryOpNode implements ASTNode {
    ASTNode left;
    ASTNode right;
    String operator;

    <T> T accept(ASTVisitor<T> visitor) {
        return visitor.visitBinaryOp(this);
    }
}

class VariableNode implements ASTNode {
    String name;

    <T> T accept(ASTVisitor<T> visitor) {
        return visitor.visitVariable(this);
    }
}
```

#### **Paso 3: Implementar un Visitor concreto**

```java
class TypeCheckVisitor implements ASTVisitor<Type> {
    SymbolTable symbolTable;

    @Override
    public Type visitBinaryOp(BinaryOpNode node) {
        // Verificar tipos de operandos
        Type leftType = node.left.accept(this);  // RecursiÃ³n: visitar hijo izquierdo
        Type rightType = node.right.accept(this); // RecursiÃ³n: visitar hijo derecho

        // Verificar compatibilidad
        if (!leftType.equals(rightType)) {
            throw new SemanticException("Tipos incompatibles: " + leftType + " y " + rightType);
        }

        return leftType; // Tipo del resultado
    }

    @Override
    public Type visitVariable(VariableNode node) {
        // Buscar variable en tabla de sÃ­mbolos
        Symbol symbol = symbolTable.lookup(node.name);
        if (symbol == null) {
            throw new SemanticException("Variable no declarada: " + node.name);
        }
        return symbol.type;
    }

    @Override
    public Type visitNumber(NumberNode node) {
        return Type.INT; // Los nÃºmeros son int
    }
}
```

#### **Paso 4: Usar el Visitor**

```java
// Construir AST: x + 5
ASTNode ast = new BinaryOpNode(
    new VariableNode("x"),  // left
    new NumberNode(5),      // right
    "+"                     // operator
);

// Verificar tipos
TypeCheckVisitor typeChecker = new TypeCheckVisitor(symbolTable);
Type resultType = ast.accept(typeChecker);

System.out.println("Tipo del resultado: " + resultType); // Type.INT
```

### **Diagrama de flujo: Â¿CÃ³mo interactÃºan los componentes?**

```mermaid
sequenceDiagram
    participant Main
    participant AST as BinaryOpNode
    participant Left as VariableNode "x"
    participant Right as NumberNode "5"
    participant Visitor as TypeCheckVisitor
    participant ST as SymbolTable

    Main->>AST: ast.accept(typeChecker)
    AST->>Visitor: visitBinaryOp(this)
    Visitor->>Left: left.accept(this)
    Left->>Visitor: visitVariable(this)
    Visitor->>ST: lookup("x")
    ST-->>Visitor: Symbol(x, Type.INT)
    Visitor-->>Left: Type.INT
    Left-->>AST: Type.INT
    Visitor->>Right: right.accept(this)
    Right->>Visitor: visitNumber(this)
    Visitor-->>Right: Type.INT
    Right-->>AST: Type.INT
    Visitor->>Visitor: Verificar INT == INT âœ“
    AST-->>Main: Type.INT
```

### **Ejemplo completo paso a paso**

**CÃ³digo fuente:**
```java
int x = 10;
int y = x + 5;
```

**AST:**
```
Program
â”œâ”€â”€ VariableDeclaration(x, 10)
â””â”€â”€ VariableDeclaration(y, x + 5)
    â””â”€â”€ BinaryOp(+)
        â”œâ”€â”€ Variable("x")
        â””â”€â”€ Number(5)
```

**EjecuciÃ³n del TypeCheckVisitor:**

| Paso | Nodo visitado | AcciÃ³n | Resultado |
|------|---------------|--------|-----------|
| 1 | VariableDeclaration(x) | Insertar x:int en tabla | âœ“ OK |
| 2 | VariableDeclaration(y) | Visitar expresiÃ³n (x + 5) | â†’ Paso 3 |
| 3 | BinaryOp(+) | Verificar operandos | â†’ Pasos 4 y 5 |
| 4 | Variable("x") | Buscar x en tabla â†’ Type.INT | Type.INT |
| 5 | Number(5) | Literal numÃ©rico | Type.INT |
| 6 | BinaryOp(+) | INT + INT = âœ“ OK | Type.INT |
| 7 | VariableDeclaration(y) | Insertar y:int en tabla | âœ“ OK |

### **Ventajas del patrÃ³n Visitor**

| Sin Visitor | Con Visitor |
|-------------|-------------|
| Modificar cada clase de nodo para nueva operaciÃ³n | Solo crear nueva clase Visitor |
| CÃ³digo mezclado en nodos | Operaciones separadas por Visitor |
| DifÃ­cil agregar operaciones | FÃ¡cil agregar operaciones |
| FÃ¡cil agregar nuevos tipos de nodos | DifÃ­cil agregar nuevos tipos de nodos |

### **Â¿CuÃ¡ndo usar Visitor?**

âœ… **USA Visitor cuando:**
- Tienes una estructura de datos estable (tipos de nodos no cambian mucho)
- Necesitas agregar muchas operaciones sobre esa estructura
- Quieres separar las operaciones de las estructuras

âŒ **NO uses Visitor cuando:**
- La estructura cambia constantemente (agregas nuevos tipos de nodos todo el tiempo)
- Solo tienes 1-2 operaciones

### **Resumen visual**

```
SIN VISITOR:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BinaryOpNode   â”‚     â”‚  VariableNode   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ typeCheck()     â”‚     â”‚ typeCheck()     â”‚
â”‚ generateCode()  â”‚     â”‚ generateCode()  â”‚
â”‚ optimize()      â”‚     â”‚ optimize()      â”‚
â”‚ prettyPrint()   â”‚     â”‚ prettyPrint()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Nueva operaciÃ³n â†’ Modificar AMBAS clases âŒ

CON VISITOR:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BinaryOpNode   â”‚     â”‚  VariableNode   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ accept(visitor) â”‚     â”‚ accept(visitor) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“                       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         TypeCheckVisitor             â”‚
â”‚  visitBinaryOp()   visitVariable()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Nueva operaciÃ³n â†’ Solo crear nueva clase Visitor âœ“
```

### **Pregunta de comprensiÃ³n**

Â¿QuÃ© hace este cÃ³digo?

```java
class CountNodesVisitor implements ASTVisitor<Integer> {
    public Integer visitBinaryOp(BinaryOpNode node) {
        return 1 + node.left.accept(this) + node.right.accept(this);
    }

    public Integer visitVariable(VariableNode node) {
        return 1;
    }

    public Integer visitNumber(NumberNode node) {
        return 1;
    }
}
```

**Respuesta:** Cuenta el nÃºmero total de nodos en el AST recursivamente. Para cada nodo binario, cuenta 1 (Ã©l mismo) + nodos en subÃ¡rbol izquierdo + nodos en subÃ¡rbol derecho.

---

## PÃ¡gina 7: ImplementaciÃ³n de la Tabla de SÃ­mbolos - ExplicaciÃ³n Detallada

Ahora veamos CÃ“MO se implementa la tabla de sÃ­mbolos en cÃ³digo.

### **Parte 1: La clase Symbol (SÃ­mbolo individual)**

```java
class Symbol {
    String name;          // El nombre del identificador (ej: "x", "contador")
    Type type;            // El tipo (ej: int, double, boolean)
    Scope scope;          // El alcance (global, local, funciÃ³n)
    Object value;         // El valor actual (opcional)
    int lineNumber;       // LÃ­nea donde fue declarado

    public Symbol(String name, Type type, Scope scope, int lineNumber) {
        this.name = name;
        this.type = type;
        this.scope = scope;
        this.lineNumber = lineNumber;
    }
}
```

**ExplicaciÃ³n de cada campo:**

1. **`name`**: El identificador que el programador escribiÃ³
   - Ejemplo: `int contador = 0;` â†’ name = "contador"

2. **`type`**: El tipo de datos
   - Ejemplo: `int contador = 0;` â†’ type = Type.INT

3. **`scope`**: El alcance de la variable
   - `Scope.GLOBAL`: Variable visible en todo el programa
   - `Scope.LOCAL`: Variable visible solo en un bloque o funciÃ³n

4. **`value`**: El valor actual (Ãºtil para optimizaciones)
   - Ejemplo: `int x = 5;` â†’ value = 5

5. **`lineNumber`**: Para reportar errores
   - Ejemplo: "Variable 'x' ya declarada en lÃ­nea 15"

### **Parte 2: La clase SymbolTable (Tabla completa)**

```java
class SymbolTable {
    // CAMPO 1: HashMap para almacenar sÃ­mbolos
    // Â¿Por quÃ© HashMap? BÃºsqueda O(1) - muy rÃ¡pido
    private Map<String, Symbol> symbols;

    // CAMPO 2: Referencia al scope padre (para scopes anidados)
    private SymbolTable parent;

    // CONSTRUCTOR
    public SymbolTable(SymbolTable parent) {
        this.symbols = new HashMap<>();  // Crear HashMap vacÃ­o
        this.parent = parent;             // Guardar referencia al padre
    }

    // ... mÃ©todos abajo
}
```

**Â¿Por quÃ© usamos HashMap?**

```
HashMap: bÃºsqueda en O(1) (constante, muy rÃ¡pido)
Array:   bÃºsqueda en O(n) (lineal, lento con muchas variables)
ArrayList: bÃºsqueda en O(n) (lineal, lento)

Con 1000 variables:
- HashMap: 1 operaciÃ³n
- Array/ArrayList: hasta 1000 operaciones

Â¡HashMap es MUCHO mÃ¡s eficiente!
```

**Â¿QuÃ© es `parent`?**

El `parent` es una referencia al scope "exterior". Esto permite tener scopes anidados:

```
Global Scope (parent = null)
  â””â”€ FunciÃ³n foo (parent = Global)
      â””â”€ Bloque if (parent = foo)
          â””â”€ Bloque anidado (parent = if)
```

### **MÃ©todo 1: `insert()` - Agregar sÃ­mbolo**

```java
public void insert(Symbol symbol) throws SemanticException {
    // PASO 1: Verificar si ya existe en el scope ACTUAL
    if (symbols.containsKey(symbol.name)) {
        // Ya existe â†’ ERROR
        throw new SemanticException(
            "Variable '" + symbol.name + "' ya declarada en lÃ­nea " +
            symbols.get(symbol.name).lineNumber
        );
    }

    // PASO 2: No existe â†’ agregar al HashMap
    symbols.put(symbol.name, symbol);
}
```

**ExplicaciÃ³n detallada:**

1. **`symbols.containsKey(symbol.name)`**
   - Pregunta: Â¿La clave (nombre) ya existe en el HashMap?
   - Ejemplo: Si ya tenemos `x:int`, y queremos agregar otro `x`, esto devuelve `true`

2. **Si existe â†’ `throw new SemanticException(...)`**
   - Lanzar una excepciÃ³n con mensaje descriptivo
   - El mensaje incluye el nombre de la variable y la lÃ­nea donde se declarÃ³ primero

3. **Si NO existe â†’ `symbols.put(symbol.name, symbol)`**
   - Agregar el nuevo sÃ­mbolo al HashMap
   - Clave = nombre, Valor = objeto Symbol completo

**Ejemplo de uso:**

```java
SymbolTable table = new SymbolTable(null);  // Tabla vacÃ­a

// Declarar: int x = 5;
Symbol xSymbol = new Symbol("x", Type.INT, Scope.GLOBAL, 1);
table.insert(xSymbol);  // âœ“ OK, tabla ahora tiene {x:int}

// Intentar declarar: int x = 10; en lÃ­nea 2
Symbol xSymbol2 = new Symbol("x", Type.INT, Scope.GLOBAL, 2);
table.insert(xSymbol2);  // âœ— LANZA EXCEPCIÃ“N:
// "Variable 'x' ya declarada en lÃ­nea 1"
```

### **MÃ©todo 2: `lookup()` - Buscar sÃ­mbolo**

```java
public Symbol lookup(String name) {
    // PASO 1: Buscar en el scope ACTUAL (this.symbols)
    Symbol symbol = symbols.get(name);

    // PASO 2: Si lo encontramos, retornarlo
    if (symbol != null) {
        return symbol;  // Encontrado en scope actual
    }

    // PASO 3: No estÃ¡ en scope actual, buscar en scope padre
    if (parent != null) {
        return parent.lookup(name);  // RecursiÃ³n: buscar en padre
    }

    // PASO 4: No encontrado en ningÃºn scope
    return null;  // La variable no existe
}
```

**ExplicaciÃ³n detallada:**

1. **`symbols.get(name)`**
   - Buscar en el HashMap del scope actual
   - Si existe, HashMap devuelve el Symbol
   - Si NO existe, HashMap devuelve `null`

2. **`if (symbol != null) return symbol;`**
   - Si encontramos el sÃ­mbolo en el scope actual, retornarlo inmediatamente
   - No necesitamos seguir buscando

3. **`if (parent != null) return parent.lookup(name);`**
   - Si NO encontramos en scope actual, preguntar al scope padre
   - **RecursiÃ³n:** El padre hace el mismo proceso (buscar en sÃ­ mismo, luego en SU padre)
   - Esto permite buscar en TODOS los scopes desde el mÃ¡s interno al mÃ¡s externo

4. **`return null;`**
   - Llegamos al scope mÃ¡s externo (parent == null) y no encontramos nada
   - La variable NO existe en ningÃºn scope
   - El analizador semÃ¡ntico puede reportar error: "Variable no declarada"

**Ejemplo visual de bÃºsqueda:**

```java
// Scopes anidados:
Global: {x: 10}
  â””â”€ FunciÃ³n foo: {y: 20}
      â””â”€ Bloque if: {z: 30}

// Si estamos en el bloque "if" y hacemos lookup("y"):

Paso 1: Buscar "y" en scope if
        if.symbols.get("y") â†’ null (no estÃ¡ aquÃ­)

Paso 2: if.parent != null â†’ TRUE (parent es foo)
        Llamar foo.lookup("y")

Paso 3: Buscar "y" en scope foo
        foo.symbols.get("y") â†’ Symbol(y, int, 20) âœ“ ENCONTRADO

Paso 4: Retornar Symbol(y, int, 20)
```

**Ejemplo en cÃ³digo:**

```java
// Crear estructura de scopes
SymbolTable global = new SymbolTable(null);
SymbolTable foo = new SymbolTable(global);
SymbolTable ifBlock = new SymbolTable(foo);

// Agregar variables
global.insert(new Symbol("x", Type.INT, Scope.GLOBAL, 1));
foo.insert(new Symbol("y", Type.INT, Scope.LOCAL, 5));
ifBlock.insert(new Symbol("z", Type.INT, Scope.LOCAL, 10));

// BÃºsquedas desde ifBlock
Symbol resultZ = ifBlock.lookup("z");  // Encuentra en scope actual
Symbol resultY = ifBlock.lookup("y");  // Encuentra en scope padre
Symbol resultX = ifBlock.lookup("x");  // Encuentra en scope abuelo
Symbol resultW = ifBlock.lookup("w");  // null - no existe
```

**Traza de `ifBlock.lookup("y")`:**

```
1. ifBlock.lookup("y")
   - Buscar en ifBlock.symbols: null
   - parent != null â†’ TRUE
   - Llamar parent.lookup("y")

2. foo.lookup("y")
   - Buscar en foo.symbols: Symbol(y, int, 20) âœ“
   - return Symbol(y, int, 20)

3. ifBlock recibe: Symbol(y, int, 20)
   - return Symbol(y, int, 20)

Resultado final: Symbol(y, int, 20)
```

### **MÃ©todo 3: `existsInCurrentScope()` - Verificar solo scope actual**

```java
public boolean existsInCurrentScope(String name) {
    return symbols.containsKey(name);
}
```

**Â¿Para quÃ© sirve?**

Este mÃ©todo NO busca en scopes padres, solo en el scope actual.

**Uso:** Detectar redeclaraciones en el mismo scope.

**Ejemplo:**

```java
void foo() {
    int x = 5;
    int x = 10;  // âœ— ERROR: x ya declarado en este scope
}
```

vs.

```java
int x = 5;  // Scope global

void foo() {
    int x = 10;  // âœ“ OK: shadowing, diferente scope
}
```

**Diferencia entre `lookup()` y `existsInCurrentScope()`:**

```java
SymbolTable global = new SymbolTable(null);
SymbolTable local = new SymbolTable(global);

global.insert(new Symbol("x", Type.INT, Scope.GLOBAL, 1));

// Desde local:
local.lookup("x");                  // âœ“ Encuentra x (busca en global tambiÃ©n)
local.existsInCurrentScope("x");    // âœ— NO encuentra (solo busca en local)
```

### **Ventajas de esta implementaciÃ³n:**

1. **Eficiencia:** HashMap da bÃºsqueda O(1)
2. **Scopes anidados:** La referencia `parent` permite jerarquÃ­as
3. **DetecciÃ³n de errores:**
   - Redeclaraciones: `existsInCurrentScope()`
   - Variables no declaradas: `lookup()` retorna null
4. **Shadowing:** Permitimos variables con mismo nombre en diferentes scopes

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© retorna este cÃ³digo?

```java
SymbolTable global = new SymbolTable(null);
SymbolTable local = new SymbolTable(global);

global.insert(new Symbol("x", Type.INT, Scope.GLOBAL, 1));
local.insert(new Symbol("y", Type.INT, Scope.LOCAL, 5));

Symbol a = local.lookup("x");
Symbol b = local.lookup("y");
Symbol c = local.lookup("z");
```

**Respuesta:**
```
a = Symbol(x, int, global) - encontrado en padre
b = Symbol(y, int, local)  - encontrado en scope actual
c = null                    - no existe en ningÃºn scope
```

---

## PÃ¡gina 7: Scopes y Contextos - Entendiendo el Alcance

### **Â¿QuÃ© es un Scope (Ãmbito)?**

Un **scope** es la regiÃ³n del cÃ³digo donde un identificador es vÃ¡lido y puede ser usado.

**AnalogÃ­a:** Piensa en los scopes como habitaciones en una casa:
- Puedes ver lo que estÃ¡ en tu habitaciÃ³n (scope local)
- Puedes ver lo que estÃ¡ en el pasillo (scope padre)
- Puedes ver lo que estÃ¡ en la sala (scope global)
- NO puedes ver lo que estÃ¡ en la habitaciÃ³n de tu hermano (scope hermano)

```mermaid
graph TB
    A[Global Scope<br/>Casa completa] --> B[FunciÃ³n main<br/>HabitaciÃ³n 1]
    A --> C[FunciÃ³n foo<br/>HabitaciÃ³n 2]
    B --> D[Bloque if<br/>Closet en Hab.1]
    B --> E[Bloque while<br/>BaÃ±o en Hab.1]
    D --> F[Bloque anidado<br/>CajÃ³n en Closet]

    style A fill:#e3f2fd,stroke:#1976d2
    style B fill:#fff3e0,stroke:#f57c00
    style C fill:#fff3e0,stroke:#f57c00
    style D fill:#fce4ec,stroke:#c2185b
    style E fill:#fce4ec,stroke:#c2185b
    style F fill:#f3e5f5,stroke:#7b1fa2
```

### **Ejemplo paso a paso con mÃºltiples scopes:**

Analicemos este cÃ³digo lÃ­nea por lÃ­nea:

```java
// SCOPE GLOBAL
int global = 100;           // LÃ­nea 1: Scope global

void foo() {                // LÃ­nea 3: Inicio scope funciÃ³n
    int local = 50;         // LÃ­nea 4: Scope funciÃ³n foo

    if (local > 0) {        // LÃ­nea 6: Inicio scope bloque if
        int nested = 25;    // LÃ­nea 7: Scope bloque if
        System.out.println(global);  // LÃ­nea 8
        System.out.println(local);   // LÃ­nea 9
        System.out.println(nested);  // LÃ­nea 10
    }                       // LÃ­nea 11: Fin scope bloque if

    System.out.println(nested);  // LÃ­nea 13: âœ— ERROR
}                           // LÃ­nea 14: Fin scope funciÃ³n

void bar() {                // LÃ­nea 16: Inicio scope funciÃ³n bar
    System.out.println(local);   // LÃ­nea 17: âœ— ERROR
}
```

**AnÃ¡lisis detallado:**

#### **LÃ­nea 1: `int global = 100;`**

**Scope:** GLOBAL
**AcciÃ³n:** Crear variable "global" en scope global

**Tabla de SÃ­mbolos Global:**

| Nombre | Tipo | Scope  |
|--------|------|--------|
| global | int  | global |

#### **LÃ­nea 4: `int local = 50;` (dentro de `foo`)**

**Scope:** FUNCIÃ“N FOO (hijo de global)
**AcciÃ³n:** Crear variable "local" en scope de foo

**Tabla de SÃ­mbolos de foo:**

| Nombre | Tipo | Scope |
|--------|------|-------|
| local  | int  | local |

**Tabla Global (padre de foo):**

| Nombre | Tipo | Scope  |
|--------|------|--------|
| global | int  | global |

#### **LÃ­nea 7: `int nested = 25;` (dentro del `if`)**

**Scope:** BLOQUE IF (hijo de foo, nieto de global)
**AcciÃ³n:** Crear variable "nested" en scope del if

**Tabla de SÃ­mbolos del bloque if:**

| Nombre | Tipo | Scope |
|--------|------|-------|
| nested | int  | local |

#### **LÃ­nea 8: `System.out.println(global);`**

```
Scope actual: BLOQUE IF
Pregunta: Â¿Existe "global"?

BÃºsqueda:
1. Buscar en scope if â†’ No encontrado
2. Buscar en scope foo (padre) â†’ No encontrado
3. Buscar en scope global (abuelo) â†’ âœ“ ENCONTRADO

Resultado: âœ“ OK, usar global = 100
```

#### **LÃ­nea 9: `System.out.println(local);`**

```
Scope actual: BLOQUE IF
Pregunta: Â¿Existe "local"?

BÃºsqueda:
1. Buscar en scope if â†’ No encontrado
2. Buscar en scope foo (padre) â†’ âœ“ ENCONTRADO

Resultado: âœ“ OK, usar local = 50
```

#### **LÃ­nea 10: `System.out.println(nested);`**

```
Scope actual: BLOQUE IF
Pregunta: Â¿Existe "nested"?

BÃºsqueda:
1. Buscar en scope if â†’ âœ“ ENCONTRADO

Resultado: âœ“ OK, usar nested = 25
```

#### **LÃ­nea 13: `System.out.println(nested);`** (fuera del `if`)

```
Scope actual: FUNCIÃ“N FOO
Pregunta: Â¿Existe "nested"?

BÃºsqueda:
1. Buscar en scope foo â†’ No encontrado
2. Buscar en scope global (padre) â†’ No encontrado
3. No hay mÃ¡s scopes padre

Resultado: âœ— ERROR
Error: Variable 'nested' no declarada en lÃ­nea 13
```

**Â¿Por quÃ©?** Porque `nested` fue declarada en el scope del `if`, y ya salimos de ese scope (lÃ­nea 11).

#### **LÃ­nea 17: `System.out.println(local);`** (en funciÃ³n `bar`)

```
Scope actual: FUNCIÃ“N BAR
Pregunta: Â¿Existe "local"?

BÃºsqueda:
1. Buscar en scope bar â†’ No encontrado
2. Buscar en scope global (padre) â†’ No encontrado
3. No hay mÃ¡s scopes padre

Resultado: âœ— ERROR
Error: Variable 'local' no declarada en lÃ­nea 17
```

**Â¿Por quÃ©?** Porque `local` fue declarada en el scope de `foo`, y `bar` es una funciÃ³n HERMANA (no hija) de `foo`. Los scopes hermanos NO pueden verse entre sÃ­.

### **Reglas de scope (MEMORIZA ESTO):**

```
1. SCOPE ACTUAL:
   âœ“ Puedes ver todas las variables declaradas en el scope actual

2. SCOPES PADRE (hacia arriba):
   âœ“ Puedes ver todas las variables de scopes padre/abuelo/etc.
   Buscar desde el mÃ¡s interno hacia el mÃ¡s externo

3. SCOPES HIJO (hacia abajo):
   âœ— NO puedes ver variables de scopes hijos

4. SCOPES HERMANO (lateral):
   âœ— NO puedes ver variables de scopes hermanos
```

### **Diagrama de visibilidad:**

```
Global Scope {global}
   â†“ (visible hacia abajo)
   â”œâ”€ FunciÃ³n foo {local}
   â”‚    â†“ (visible hacia abajo)
   â”‚    â””â”€ Bloque if {nested}
   â”‚         â†‘ (busca hacia arriba)
   â”‚         âœ“ Puede ver: nested, local, global
   â”‚
   â””â”€ FunciÃ³n bar {}
        âœ— NO puede ver: local (estÃ¡ en foo, scope hermano)
        âœ“ PUEDE ver: global (scope padre)
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© imprime este cÃ³digo y dÃ³nde hay errores?

```java
int a = 10;

void test() {
    int b = 20;

    {
        int c = 30;
        System.out.println(a);  // LÃ­nea 7
        System.out.println(b);  // LÃ­nea 8
        System.out.println(c);  // LÃ­nea 9
    }

    System.out.println(c);      // LÃ­nea 12
}
```

**Respuesta:**

```
LÃ­nea 7: âœ“ OK - Imprime 10 (a estÃ¡ en global, visible)
LÃ­nea 8: âœ“ OK - Imprime 20 (b estÃ¡ en test, visible)
LÃ­nea 9: âœ“ OK - Imprime 30 (c estÃ¡ en scope actual)
LÃ­nea 12: âœ— ERROR - c no visible (declarada en bloque interno que ya terminÃ³)
```

---

## PÃ¡gina 8: Scopes Anidados - ImplementaciÃ³n y Shadowing Detallado

### **Â¿QuÃ© es el Shadowing?**

**Shadowing** (sombreado) ocurre cuando declaras una variable con el mismo nombre que otra en un scope padre. La variable del scope mÃ¡s interno "oculta" a la del scope externo.

**AnalogÃ­a:** Es como tener dos personas llamadas "Juan" en tu familia:
- Juan (abuelo) - vive en la casa principal
- Juan (nieto) - vive en tu habitaciÃ³n

Cuando estÃ¡s en tu habitaciÃ³n y dices "Juan", te refieres al nieto, no al abuelo. El nieto "sombrea" al abuelo.

### **Diagrama visual de shadowing:**

```mermaid
graph TB
    subgraph "Global Scope"
        G1[x = 10<br/>La variable original]
        subgraph "FunciÃ³n foo Scope"
            F1[x = 20<br/>Sombrea a x global]
            F2[y = 30<br/>Variable Ãºnica]
            subgraph "Bloque if Scope"
                B1[x = 40<br/>Sombrea a x de foo]
                B2[z = 50<br/>Variable Ãºnica]
            end
        end
    end

    style G1 fill:#ffebee,stroke:#c62828
    style F1 fill:#fff3e0,stroke:#ef6c00
    style F2 fill:#fff3e0,stroke:#ef6c00
    style B1 fill:#e8f5e9,stroke:#2e7d32
    style B2 fill:#e8f5e9,stroke:#2e7d32
```

### **Ejemplo paso a paso con shadowing:**

Analicemos este cÃ³digo en detalle:

```java
int x = 10;  // LÃ­nea 1: x global

void foo() {
    int x = 20;  // LÃ­nea 4: x local (shadowing)
    System.out.println("En foo: " + x);  // LÃ­nea 5

    {
        int x = 40;  // LÃ­nea 8: x en bloque (shadowing)
        System.out.println("En bloque: " + x);  // LÃ­nea 9
    }

    System.out.println("De vuelta en foo: " + x);  // LÃ­nea 12
}

System.out.println("Global: " + x);  // LÃ­nea 15
```

#### **LÃ­nea 1: Declarar x global**

```
CÃ³digo: int x = 10;
Scope: GLOBAL

AcciÃ³n:
1. Crear SymbolTable global (parent = null)
2. Insertar Symbol("x", int, 10) en tabla global
```

**Tabla Global:**

| Nombre | Tipo | Scope  | Valor |
|--------|------|--------|-------|
| x      | int  | global | 10    |

```
Estado: 1 scope, 1 variable
```

#### **LÃ­nea 4: Declarar x en foo (SHADOWING)**

```
CÃ³digo: int x = 20;
Scope: FUNCIÃ“N FOO

Preguntas del analizador:
1. Â¿"x" existe en el scope ACTUAL (foo)? â†’ No
2. Â¿"x" existe en algÃºn scope padre? â†’ SÃ­ (global)
3. Â¿Es shadowing? â†’ SÃ­ (mismo nombre, diferente scope)

DecisiÃ³n: âœ“ PERMITIR (shadowing es vÃ¡lido)

AcciÃ³n:
1. Crear SymbolTable foo (parent = global)
2. Insertar Symbol("x", int, 20) en tabla foo
```

**Tabla de foo:**

| Nombre | Tipo | Scope | Valor |
|--------|------|-------|-------|
| x      | int  | local | 20    |

   â†‘ parent â†“

**Tabla Global:**

| Nombre | Tipo | Scope  | Valor |
|--------|------|--------|-------|
| x      | int  | global | 10    |

```
Estado: 2 scopes, 2 variables "x" (diferentes scopes)
```

**ExplicaciÃ³n:** El mÃ©todo `existsInCurrentScope("x")` retorna `false` porque busca SOLO en foo, no en global. Por eso se permite la declaraciÃ³n.

#### **LÃ­nea 5: Usar x en foo**

```
CÃ³digo: System.out.println("En foo: " + x);
Scope actual: FOO

BÃºsqueda de "x":
1. foo.lookup("x")
   - Buscar en foo.symbols: âœ“ ENCONTRADO (x = 20)
   - return Symbol("x", int, 20)

NO necesita buscar en global porque ya encontrÃ³ "x" en el scope actual.

Resultado: Imprime "En foo: 20"
```

**Clave:** `lookup()` siempre retorna la variable del scope MÃS INTERNO primero.

#### **LÃ­nea 8: Declarar x en bloque (DOBLE SHADOWING)**

```
CÃ³digo: int x = 40;
Scope: BLOQUE (hijo de foo)

Preguntas del analizador:
1. Â¿"x" existe en el scope ACTUAL (bloque)? â†’ No
2. Â¿"x" existe en algÃºn scope padre? â†’ SÃ­ (foo Y global)
3. Â¿Es shadowing? â†’ SÃ­ (sombrea a AMBOS)

DecisiÃ³n: âœ“ PERMITIR

AcciÃ³n:
1. Crear SymbolTable bloque (parent = foo)
2. Insertar Symbol("x", int, 40) en tabla bloque
```

**Tabla de bloque:**

| Nombre | Tipo | Scope | Valor |
|--------|------|-------|-------|
| x      | int  | local | 40    |

   â†‘ parent â†“

**Tabla de foo:**

| Nombre | Tipo | Scope | Valor |
|--------|------|-------|-------|
| x      | int  | local | 20    |

   â†‘ parent â†“

**Tabla Global:**

| Nombre | Tipo | Scope  | Valor |
|--------|------|--------|-------|
| x      | int  | global | 10    |

```
Estado: 3 scopes, 3 variables "x" (todas en scopes diferentes)
```

#### **LÃ­nea 9: Usar x en bloque**

```
CÃ³digo: System.out.println("En bloque: " + x);
Scope actual: BLOQUE

BÃºsqueda de "x":
1. bloque.lookup("x")
   - Buscar en bloque.symbols: âœ“ ENCONTRADO (x = 40)
   - return Symbol("x", int, 40)

NO busca en foo ni en global porque ya encontrÃ³ "x" en scope actual.

Resultado: Imprime "En bloque: 40"
```

#### **LÃ­nea 10: Salir del bloque**

```
AcciÃ³n: Al cerrar }, el scope del bloque se DESTRUYE

Efecto:
1. La tabla de sÃ­mbolos del bloque se elimina
2. La variable "x = 40" YA NO EXISTE
3. Volvemos al scope de foo
```

**Tabla activa ahora: foo**

| Nombre | Tipo | Scope | Valor |
|--------|------|-------|-------|
| x      | int  | local | 20    |

```
La x del bloque (40) desapareciÃ³.
```

#### **LÃ­nea 12: Usar x de vuelta en foo**

```
CÃ³digo: System.out.println("De vuelta en foo: " + x);
Scope actual: FOO (el bloque ya no existe)

BÃºsqueda de "x":
1. foo.lookup("x")
   - Buscar en foo.symbols: âœ“ ENCONTRADO (x = 20)
   - return Symbol("x", int, 20)

Resultado: Imprime "De vuelta en foo: 20"
```

**ObservaciÃ³n:** La x del bloque (40) desapareciÃ³. Ahora vemos la x de foo (20).

#### **LÃ­nea 15: Usar x global (fuera de foo)**

```
CÃ³digo: System.out.println("Global: " + x);
Scope actual: GLOBAL (foo ya terminÃ³)

BÃºsqueda de "x":
1. global.lookup("x")
   - Buscar en global.symbols: âœ“ ENCONTRADO (x = 10)
   - return Symbol("x", int, 10)

Resultado: Imprime "Global: 10"
```

### **Salida completa del programa:**

```
En foo: 20
En bloque: 40
De vuelta en foo: 20
Global: 10
```

### **ImplementaciÃ³n del algoritmo de bÃºsqueda con shadowing:**

```java
public Symbol lookup(String name) {
    // PASO 1: Buscar en scope ACTUAL primero
    Symbol symbol = symbols.get(name);

    if (symbol != null) {
        // ENCONTRADO en scope actual
        // Esto implementa el shadowing: la variable local
        // "sombrea" a las variables con mismo nombre en scopes padre
        return symbol;
    }

    // PASO 2: No encontrado en scope actual, buscar en padre
    if (parent != null) {
        return parent.lookup(name);
    }

    // PASO 3: No encontrado en ningÃºn scope
    return null;
}
```

**ExplicaciÃ³n del shadowing en el cÃ³digo:**

```
Cuando hacemos lookup("x") desde el bloque:

1. bloque.lookup("x")
   - symbols.get("x") â†’ Symbol(x, 40) âœ“
   - return Symbol(x, 40) INMEDIATAMENTE
   - NO busca en foo ni en global

El "if (symbol != null) return symbol;" implementa el shadowing.
La primera coincidencia (scope mÃ¡s interno) gana.
```

### **Diferencia entre shadowing y redeclaraciÃ³n:**

#### **SHADOWING (permitido):**

```java
int x = 10;  // Scope global

void foo() {
    int x = 20;  // âœ“ OK: Diferente scope (sombrea a global)
}
```

**VerificaciÃ³n:**
```java
// Desde scope de foo:
existsInCurrentScope("x") â†’ false (no estÃ¡ en foo directamente)
lookup("x") â†’ Symbol(x, 10) desde global

// Por eso se permite declarar x en foo
```

#### **REDECLARACIÃ“N (prohibido):**

```java
void foo() {
    int x = 10;  // LÃ­nea 2
    int x = 20;  // LÃ­nea 3: âœ— ERROR: redeclaraciÃ³n
}
```

**VerificaciÃ³n:**
```java
// En lÃ­nea 3, desde scope de foo:
existsInCurrentScope("x") â†’ true (x YA estÃ¡ en foo desde lÃ­nea 2)

// Por eso se rechaza: ERROR
```

### **Reglas de shadowing (MEMORIZA):**

```
âœ“ PERMITIDO (shadowing):
  - Mismo nombre
  - Diferentes scopes (padre e hijo)
  - La variable mÃ¡s interna "gana"

âœ— PROHIBIDO (redeclaraciÃ³n):
  - Mismo nombre
  - MISMO scope
  - Error: variable ya declarada
```

### **Ejemplo de verificaciÃ³n en cÃ³digo:**

```java
public void visitDeclarationNode(DeclarationNode node) {
    // Verificar SOLO en scope actual (no en padres)
    if (symbolTable.existsInCurrentScope(node.name)) {
        // âœ— ERROR: RedeclaraciÃ³n en MISMO scope
        throw new SemanticException(
            "Variable '" + node.name + "' ya declarada en este scope"
        );
    }

    // No existe en scope actual â†’ OK
    // Puede existir en scope padre (shadowing), pero estÃ¡ permitido
    Symbol symbol = new Symbol(node.name, node.type, currentScope, node.line);
    symbolTable.insert(symbol);
}
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© imprime este cÃ³digo?

```java
int a = 1;

void test() {
    System.out.println(a);  // LÃ­nea 4
    int a = 2;
    System.out.println(a);  // LÃ­nea 6

    {
        int a = 3;
        System.out.println(a);  // LÃ­nea 9
    }

    System.out.println(a);  // LÃ­nea 12
}

System.out.println(a);  // LÃ­nea 15
```

**Respuesta:**

```
LÃ­nea 4: Imprime 1 (usa a global, la local aÃºn no se declara)
LÃ­nea 6: Imprime 2 (usa a local de test)
LÃ­nea 9: Imprime 3 (usa a del bloque, sombrea a test)
LÃ­nea 12: Imprime 2 (a del bloque ya no existe, usa a de test)
LÃ­nea 15: Imprime 1 (usa a global)
```

---

## PÃ¡gina 9: Sistema de Tipos - Fundamentos y JerarquÃ­a

### **Â¿QuÃ© es un Tipo?**

Un **tipo** es un contrato que define:
1. **QuÃ© valores puede tomar** una variable
2. **QuÃ© operaciones** se pueden hacer con esos valores

**AnalogÃ­a:** Los tipos son como categorÃ­as de objetos en el mundo real:
- **NÃºmeros (int):** Puedes sumar, restar, multiplicar
- **Texto (String):** Puedes concatenar, buscar subcadenas
- **Booleanos (boolean):** Puedes hacer AND, OR, NOT

Intentar sumar un nÃºmero con un texto no tiene sentido, igual que intentar conducir un libro no tiene sentido en el mundo real.

```mermaid
graph LR
    A[Tipo int] --> B[Valores: -2147483648 a 2147483647]
    A --> C[Operaciones: +, -, *, /, %]

    D[Tipo boolean] --> E[Valores: true, false]
    D --> F[Operaciones: &&, ||, !]

    G[Tipo String] --> H[Valores: secuencias de caracteres]
    G --> I[Operaciones: +, length, substring]
```

### **JerarquÃ­a de tipos detallada:**

#### **Clase base: Type**

```java
abstract class Type {
    String name;  // "int", "double", "String", etc.

    // MÃ©todo abstracto: cada tipo implementa su lÃ³gica
    abstract boolean isCompatible(Type other);

    // MÃ©todos de utilidad
    public boolean isNumeric() {
        return this instanceof IntType ||
               this instanceof DoubleType ||
               this instanceof FloatType ||
               this instanceof LongType;
    }

    public boolean isInt() {
        return this instanceof IntType;
    }

    public boolean isDouble() {
        return this instanceof DoubleType;
    }

    public boolean isBoolean() {
        return this instanceof BooleanType;
    }

    public boolean isString() {
        return this instanceof StringType;
    }

    @Override
    public String toString() {
        return name;
    }
}
```

**ExplicaciÃ³n:**
- `isCompatible()`: Determina si dos tipos pueden usarse juntos
- `isNumeric()`: Verifica si es un tipo numÃ©rico (para operaciones +, -, *, /)
- MÃ©todos `isX()`: Atajos para verificar tipos especÃ­ficos

#### **Tipos primitivos:**

```java
class PrimitiveType extends Type {
    // Tipos bÃ¡sicos del lenguaje

    public PrimitiveType(String name) {
        this.name = name;
    }

    @Override
    public boolean isCompatible(Type other) {
        // Tipos primitivos son compatibles si son exactamente iguales
        // O si hay promociÃ³n implÃ­cita permitida
        if (this.equals(other)) {
            return true;  // int == int, double == double, etc.
        }

        // PromociÃ³n implÃ­cita (widening)
        if (this.isInt() && other.isDouble()) {
            return true;  // int â†’ double (OK)
        }

        if (this.isChar() && other.isInt()) {
            return true;  // char â†’ int (OK)
        }

        return false;  // Otros casos: incompatible
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof PrimitiveType)) return false;
        PrimitiveType other = (PrimitiveType) obj;
        return this.name.equals(other.name);
    }
}

// Tipos especÃ­ficos (para mayor claridad)
class IntType extends PrimitiveType {
    public IntType() { super("int"); }
}

class DoubleType extends PrimitiveType {
    public DoubleType() { super("double"); }
}

class BooleanType extends PrimitiveType {
    public BooleanType() { super("boolean"); }
}

class CharType extends PrimitiveType {
    public CharType() { super("char"); }
}

class StringType extends Type {
    public StringType() { this.name = "String"; }

    @Override
    public boolean isCompatible(Type other) {
        return other instanceof StringType;
    }
}
```

**Ejemplo de uso:**

```java
Type intType = new IntType();
Type doubleType = new DoubleType();
Type stringType = new StringType();

// Verificar compatibilidad
intType.isCompatible(intType);      // true: int == int
intType.isCompatible(doubleType);   // true: int â†’ double (promociÃ³n)
doubleType.isCompatible(intType);   // false: double â†› int (pÃ©rdida)
intType.isCompatible(stringType);   // false: int â†› String (incompatible)
```

#### **Tipos compuestos: Arrays**

```java
class ArrayType extends Type {
    Type elementType;  // Tipo de los elementos del array
    int size;          // TamaÃ±o del array (-1 si es dinÃ¡mico)

    public ArrayType(Type elementType, int size) {
        this.elementType = elementType;
        this.size = size;
        this.name = elementType.name + "[]";
    }

    @Override
    public boolean isCompatible(Type other) {
        if (!(other instanceof ArrayType)) {
            return false;  // Solo compatible con otros arrays
        }

        ArrayType otherArray = (ArrayType) other;

        // Los arrays son compatibles si sus elementos son compatibles
        return this.elementType.isCompatible(otherArray.elementType);
    }

    @Override
    public String toString() {
        return elementType.toString() + "[" +
               (size >= 0 ? size : "") + "]";
    }
}
```

**Ejemplo:**

```java
// int[] array de enteros
Type intArray = new ArrayType(new IntType(), 10);

// double[] array de doubles
Type doubleArray = new ArrayType(new DoubleType(), 5);

// Verificar compatibilidad
intArray.isCompatible(intArray);      // true: int[] == int[]
intArray.isCompatible(doubleArray);   // false: int[] != double[]

// Acceso a elementos
// int[] arr â†’ arr[0] es int
((ArrayType) intArray).elementType;  // IntType
```

#### **Tipos compuestos: Funciones**

```java
class FunctionType extends Type {
    Type returnType;              // Tipo que retorna la funciÃ³n
    List<Type> parameterTypes;    // Tipos de los parÃ¡metros

    public FunctionType(Type returnType, List<Type> parameterTypes) {
        this.returnType = returnType;
        this.parameterTypes = parameterTypes;
        this.name = buildSignature();
    }

    private String buildSignature() {
        StringBuilder sb = new StringBuilder();
        sb.append("(");

        for (int i = 0; i < parameterTypes.size(); i++) {
            if (i > 0) sb.append(", ");
            sb.append(parameterTypes.get(i).name);
        }

        sb.append(") -> ");
        sb.append(returnType.name);

        return sb.toString();
    }

    @Override
    public boolean isCompatible(Type other) {
        if (!(other instanceof FunctionType)) {
            return false;
        }

        FunctionType otherFunc = (FunctionType) other;

        // Verificar tipo de retorno
        if (!this.returnType.isCompatible(otherFunc.returnType)) {
            return false;
        }

        // Verificar nÃºmero de parÃ¡metros
        if (this.parameterTypes.size() != otherFunc.parameterTypes.size()) {
            return false;
        }

        // Verificar cada parÃ¡metro
        for (int i = 0; i < parameterTypes.size(); i++) {
            if (!this.parameterTypes.get(i).isCompatible(
                    otherFunc.parameterTypes.get(i))) {
                return false;
            }
        }

        return true;  // Todas las verificaciones pasaron
    }

    @Override
    public String toString() {
        return name;
    }
}
```

**Ejemplo:**

```java
// int suma(int a, int b)
Type sumaType = new FunctionType(
    new IntType(),
    Arrays.asList(new IntType(), new IntType())
);
// Signatura: "(int, int) -> int"

// double promedio(double a, double b, double c)
Type promedioType = new FunctionType(
    new DoubleType(),
    Arrays.asList(new DoubleType(), new DoubleType(), new DoubleType())
);
// Signatura: "(double, double, double) -> double"

// Verificar compatibilidad
sumaType.isCompatible(sumaType);       // true
sumaType.isCompatible(promedioType);   // false (diferentes signaturas)
```

### **Tabla de compatibilidad de tipos:**

```
COMPATIBILIDAD DE ASIGNACIÃ“N (tipo_destino = tipo_origen)

              int  double  boolean  char  String  int[]
int           âœ“    âœ—       âœ—        âœ—     âœ—       âœ—
double        âœ“    âœ“       âœ—        âœ—     âœ—       âœ—
boolean       âœ—    âœ—       âœ“        âœ—     âœ—       âœ—
char          âœ—    âœ—       âœ—        âœ“     âœ—       âœ—
String        âœ—    âœ—       âœ—        âœ—     âœ“       âœ—
int[]         âœ—    âœ—       âœ—        âœ—     âœ—       âœ“

Leyenda:
âœ“ = Compatible (permitido)
âœ— = Incompatible (error)

Nota: int â†’ double es compatible (promociÃ³n implÃ­cita)
      double â†’ int NO es compatible (requiere cast explÃ­cito)
```

### **Ejemplos concretos de compatibilidad:**

```java
// âœ“ COMPATIBLES
int x = 5;           // int = int
double y = 5;        // double = int (promociÃ³n)
double z = 3.14;     // double = double
boolean b = true;    // boolean = boolean

// âœ— INCOMPATIBLES
int a = 3.14;        // int = double (pÃ©rdida de precisiÃ³n)
boolean c = 5;       // boolean = int (tipos diferentes)
String s = 42;       // String = int (tipos diferentes)
int[] arr = 5;       // int[] = int (tipos diferentes)
```

### **Pregunta de comprensiÃ³n:**

Â¿CuÃ¡les de estas asignaciones son vÃ¡lidas?

```java
int a = 10;
double b = a;      // Â¿VÃ¡lido?
int c = b;         // Â¿VÃ¡lido?
String d = "hola";
int e = d;         // Â¿VÃ¡lido?
```

**Respuesta:**

```
double b = a;  // âœ“ VÃLIDO: int â†’ double (promociÃ³n implÃ­cita)
int c = b;     // âœ— INVÃLIDO: double â†’ int (pÃ©rdida de precisiÃ³n)
int e = d;     // âœ— INVÃLIDO: String â†’ int (tipos incompatibles)
```

---

## PÃ¡gina 10: Arquitectura Completa del Analizador SemÃ¡ntico

### **Diagrama de arquitectura detallado:**

```mermaid
graph TB
    subgraph "INPUT"
        AST[AST del Parser<br/>SintÃ¡cticamente vÃ¡lido]
    end

    subgraph "ANALIZADOR SEMÃNTICO"
        SA[SemanticAnalyzer<br/>Coordinador Principal]

        subgraph "Componentes Core"
            ST[SymbolTable<br/>Tabla de SÃ­mbolos<br/>+ GestiÃ³n de Scopes]
            TC[TypeChecker<br/>Verificador de Tipos]
            EH[ErrorHandler<br/>Manejador de Errores]
        end

        subgraph "Visitor Pattern"
            V[ASTVisitor Interface]
            VP[visitProgramNode]
            VD[visitDeclarationNode]
            VA[visitAssignmentNode]
            VE[visitExpressionNode]
            VI[visitIfNode]
            VW[visitWhileNode]
        end

        subgraph "Sistema de Tipos"
            TB[Type Base Class]
            TP[PrimitiveType]
            TA[ArrayType]
            TF[FunctionType]
        end
    end

    subgraph "OUTPUT"
        AAST[AST Anotado<br/>con informaciÃ³n de tipos]
        STF[Tabla de SÃ­mbolos Final<br/>con todas las declaraciones]
        ERR[Lista de Errores SemÃ¡nticos<br/>si los hay]
    end

    AST --> SA
    SA --> ST
    SA --> TC
    SA --> EH
    SA --> V

    V --> VP
    V --> VD
    V --> VA
    V --> VE
    V --> VI
    V --> VW

    TC --> TB
    TB --> TP
    TB --> TA
    TB --> TF

    ST -.informaciÃ³n.-> TC
    TC -.errores.-> EH

    SA --> AAST
    SA --> STF
    SA --> ERR

    style SA fill:#ff6b6b,stroke:#c92a2a,stroke-width:3px
    style ST fill:#4ecdc4,stroke:#45b7aa,stroke-width:2px
    style TC fill:#95e1d3,stroke:#45b7aa,stroke-width:2px
    style EH fill:#ffd93d,stroke:#f9a825,stroke-width:2px
    style AST fill:#e3f2fd,stroke:#1976d2
    style AAST fill:#c8e6c9,stroke:#388e3c
```

### **ExplicaciÃ³n de cada componente:**

#### **1. SemanticAnalyzer (Coordinador Principal)**

```java
class SemanticAnalyzer implements ASTVisitor<Type> {
    // COMPONENTES PRINCIPALES
    private SymbolTable symbolTable;        // Tabla de sÃ­mbolos
    private TypeChecker typeChecker;        // Verificador de tipos
    private ErrorHandler errorHandler;      // Manejador de errores
    private List<SemanticException> errors; // Lista de errores encontrados

    // ESTADO ACTUAL
    private Scope currentScope;             // Scope actual
    private Type currentReturnType;         // Tipo de retorno esperado
    private boolean inLoop;                 // Â¿Estamos dentro de un loop?

    public SemanticAnalyzer() {
        this.symbolTable = new SymbolTable(null);
        this.typeChecker = new TypeChecker(symbolTable);
        this.errorHandler = new ErrorHandler();
        this.errors = new ArrayList<>();
        this.currentScope = Scope.GLOBAL;
        this.inLoop = false;
    }

    // MÃ‰TODO PRINCIPAL
    public void analyze(ProgramNode program) {
        try {
            program.accept(this);  // Iniciar recorrido del AST
        } catch (SemanticException e) {
            errors.add(e);
        }

        if (!errors.isEmpty()) {
            errorHandler.reportErrors(errors);
        }
    }
}
```

**Responsabilidades:**
- Coordinar todos los componentes
- Recorrer el AST usando el patrÃ³n Visitor
- Mantener el estado actual (scope, loop, tipo de retorno)
- Recolectar todos los errores encontrados

#### **2. SymbolTable (Tabla de SÃ­mbolos)**

```java
class SymbolTable {
    // Almacena sÃ­mbolos del scope actual
    private Map<String, Symbol> symbols;

    // Referencia al scope padre (para bÃºsqueda recursiva)
    private SymbolTable parent;

    // Lista de scopes hijos (para debugging)
    private List<SymbolTable> children;

    // OPERACIONES PRINCIPALES
    public void insert(Symbol symbol);          // Agregar sÃ­mbolo
    public Symbol lookup(String name);          // Buscar sÃ­mbolo
    public boolean existsInCurrentScope(String name);  // Verificar redeclaraciÃ³n
    public void enterScope();                   // Entrar a nuevo scope
    public void exitScope();                    // Salir de scope actual
}
```

**Responsabilidades:**
- Almacenar informaciÃ³n de todas las variables, funciones, clases
- Gestionar scopes anidados
- Permitir bÃºsqueda eficiente (O(1))
- Detectar redeclaraciones

#### **3. TypeChecker (Verificador de Tipos)**

```java
class TypeChecker {
    private SymbolTable symbolTable;  // Necesita acceso a la tabla

    // Verificar tipo de expresiÃ³n
    public Type checkExpression(ExpressionNode expr);

    // Verificar operaciÃ³n binaria (a + b, a == b, etc.)
    public Type checkBinaryOp(BinaryOpNode node);

    // Verificar compatibilidad de tipos
    public boolean areCompatible(Type t1, Type t2);

    // Promover tipo (int â†’ double)
    public Type promoteType(Type t1, Type t2);
}
```

**Responsabilidades:**
- Verificar que las operaciones usan tipos compatibles
- Implementar reglas de promociÃ³n de tipos
- Detectar errores de tipos

#### **4. ErrorHandler (Manejador de Errores)**

```java
class ErrorHandler {
    // Reportar un error
    public void reportError(SemanticException error);

    // Reportar mÃºltiples errores
    public void reportErrors(List<SemanticException> errors);

    // Formatear mensaje de error
    private String formatError(SemanticException error);
}
```

**Responsabilidades:**
- Recolectar todos los errores
- Formatear mensajes descriptivos
- Mostrar lÃ­nea y columna del error

### **Flujo completo del anÃ¡lisis semÃ¡ntico:**

```mermaid
sequenceDiagram
    participant Parser
    participant SA as SemanticAnalyzer
    participant V as Visitor
    participant ST as SymbolTable
    participant TC as TypeChecker
    participant EH as ErrorHandler

    Parser->>SA: AST (sintÃ¡cticamente vÃ¡lido)
    SA->>V: program.accept(this)

    loop Para cada nodo del AST
        V->>V: visitNodeType(node)

        alt Es DeclaraciÃ³n
            V->>ST: insert(symbol)
            ST-->>V: OK o ERROR
        end

        alt Es Uso de Variable
            V->>ST: lookup(name)
            ST-->>V: Symbol o null
        end

        alt Es ExpresiÃ³n
            V->>TC: checkExpression(expr)
            TC->>ST: lookup variables
            TC->>TC: verificar tipos
            TC-->>V: Type o ERROR
        end

        alt Hay Error
            V->>EH: reportError(error)
        end
    end

    SA->>EH: reportErrors(allErrors)
    SA-->>Parser: AST anotado + errores
```

### **Ejemplo de flujo completo:**

Analicemos este cÃ³digo paso a paso:

```java
int x = 5;
int y = x + 10;
```

**Traza completa del anÃ¡lisis:**

```
INICIO: SemanticAnalyzer.analyze(programNode)

â”â”â” LÃNEA 1: int x = 5; â”â”â”

1. SA llama a programNode.accept(this)
   â””â”€> visitProgramNode(programNode)

2. Encontrar DeclarationNode(type=int, name="x", value=5)
   â””â”€> visitDeclarationNode(node)

3. Verificar si "x" ya existe
   â””â”€> symbolTable.existsInCurrentScope("x")
   â””â”€> Retorna: false (no existe)

4. Verificar tipo del inicializador
   â””â”€> visitNumberNode(5)
   â””â”€> TypeChecker.checkExpression(NumberNode(5))
   â””â”€> Retorna: Type.INT

5. Verificar compatibilidad: int = int
   â””â”€> TypeChecker.areCompatible(INT, INT)
   â””â”€> Retorna: true âœ“

6. Insertar en tabla de sÃ­mbolos
   â””â”€> symbolTable.insert(Symbol("x", INT, 5, lÃ­nea=1))
   â””â”€> Tabla ahora: {x: int}

Estado despuÃ©s lÃ­nea 1:
  SymbolTable: {x: int}
  Errores: []

â”â”â” LÃNEA 2: int y = x + 10; â”â”â”

7. Encontrar DeclarationNode(type=int, name="y", value=x+10)
   â””â”€> visitDeclarationNode(node)

8. Verificar si "y" ya existe
   â””â”€> symbolTable.existsInCurrentScope("y")
   â””â”€> Retorna: false (no existe)

9. Verificar tipo del inicializador (x + 10)
   â””â”€> visitBinaryOpNode(left=x, op=+, right=10)

10. Verificar tipo de "x"
    â””â”€> visitIdentifierNode("x")
    â””â”€> symbolTable.lookup("x")
    â””â”€> Retorna: Symbol("x", INT)
    â””â”€> Tipo de x: INT

11. Verificar tipo de "10"
    â””â”€> visitNumberNode(10)
    â””â”€> Retorna: Type.INT

12. Verificar operaciÃ³n: INT + INT
    â””â”€> TypeChecker.checkBinaryOp(+, INT, INT)
    â””â”€> Retorna: Type.INT âœ“

13. Verificar compatibilidad: int = int
    â””â”€> TypeChecker.areCompatible(INT, INT)
    â””â”€> Retorna: true âœ“

14. Insertar en tabla de sÃ­mbolos
    â””â”€> symbolTable.insert(Symbol("y", INT, 15, lÃ­nea=2))
    â””â”€> Tabla ahora: {x: int, y: int}

Estado final:
  SymbolTable: {x: int, y: int}
  Errores: []
  AST Anotado:
    DeclarationNode("x", INT) [type=INT âœ“]
    DeclarationNode("y", INT) [type=INT âœ“]
      â””â”€ BinaryOpNode(+) [type=INT âœ“]
          â”œâ”€ IdentifierNode("x") [type=INT âœ“, resolvedTo=Symbol(x)]
          â””â”€ NumberNode(10) [type=INT âœ“]

FIN: AnÃ¡lisis exitoso sin errores
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© componentes se usan en cada paso del siguiente cÃ³digo?

```java
int x = 5;
y = x + 10;
```

**Respuesta:**

```
LÃ­nea 1: int x = 5;
  - SemanticAnalyzer: coordina
  - Visitor: visitDeclarationNode
  - SymbolTable: insert("x")
  - TypeChecker: checkExpression(5)
  - Resultado: âœ“ OK

LÃ­nea 2: y = x + 10;
  - SemanticAnalyzer: coordina
  - Visitor: visitAssignmentNode
  - SymbolTable: lookup("y")  â† âœ— NO EXISTE
  - ErrorHandler: reportError("Variable 'y' no declarada")
  - Resultado: âœ— ERROR
```

---

## PÃ¡gina 11: VerificaciÃ³n de Tipos - Type Checking Detallado

### **Â¿QuÃ© es Type Checking?**

**Type Checking** (verificaciÃ³n de tipos) es el proceso de verificar que las operaciones se realizan con tipos compatibles.

**AnalogÃ­a:** Es como verificar que estÃ¡s usando las herramientas correctas:
- âœ“ Martillo + Clavo = OK
- âœ— Martillo + Sopa = NO TIENE SENTIDO

### **Tipos de verificaciÃ³n:**

```mermaid
graph TB
    A[Type Checking] --> B[EstÃ¡tica<br/>Compile-time]
    A --> C[DinÃ¡mica<br/>Runtime]

    B --> D[Java, C++, TypeScript]
    B --> E[Errores encontrados temprano]
    B --> F[Mejor rendimiento]

    C --> G[Python, JavaScript, Ruby]
    C --> H[Mayor flexibilidad]
    C --> I[Errores en ejecuciÃ³n]

    style B fill:#c8e6c9,stroke:#388e3c
    style C fill:#ffe0b2,stroke:#f57c00
```

**Nuestro enfoque: VerificaciÃ³n EstÃ¡tica**

Detectamos errores de tipos ANTES de ejecutar el programa (en tiempo de compilaciÃ³n).

### **ImplementaciÃ³n completa del TypeChecker:**

```java
class TypeChecker {
    private SymbolTable symbolTable;

    public TypeChecker(SymbolTable symbolTable) {
        this.symbolTable = symbolTable;
    }

    // â”â”â” MÃ‰TODO PRINCIPAL â”â”â”
    public Type checkExpression(ExpressionNode expr) {
        if (expr instanceof NumberNode) {
            return checkNumberNode((NumberNode) expr);
        }
        else if (expr instanceof BooleanNode) {
            return checkBooleanNode((BooleanNode) expr);
        }
        else if (expr instanceof StringNode) {
            return checkStringNode((StringNode) expr);
        }
        else if (expr instanceof IdentifierNode) {
            return checkIdentifierNode((IdentifierNode) expr);
        }
        else if (expr instanceof BinaryOpNode) {
            return checkBinaryOp((BinaryOpNode) expr);
        }
        else if (expr instanceof UnaryOpNode) {
            return checkUnaryOp((UnaryOpNode) expr);
        }
        else if (expr instanceof FunctionCallNode) {
            return checkFunctionCall((FunctionCallNode) expr);
        }
        else if (expr instanceof ArrayAccessNode) {
            return checkArrayAccess((ArrayAccessNode) expr);
        }

        throw new SemanticException("Tipo de expresiÃ³n desconocido");
    }

    // â”â”â” VERIFICAR NODOS LITERALES â”â”â”
    private Type checkNumberNode(NumberNode node) {
        // Determinar si es int o double
        if (node.value % 1 == 0) {
            node.type = Type.INT;
            return Type.INT;
        } else {
            node.type = Type.DOUBLE;
            return Type.DOUBLE;
        }
    }

    private Type checkBooleanNode(BooleanNode node) {
        node.type = Type.BOOLEAN;
        return Type.BOOLEAN;
    }

    private Type checkStringNode(StringNode node) {
        node.type = Type.STRING;
        return Type.STRING;
    }

    // â”â”â” VERIFICAR IDENTIFICADORES â”â”â”
    private Type checkIdentifierNode(IdentifierNode node) {
        // Buscar variable en tabla de sÃ­mbolos
        Symbol symbol = symbolTable.lookup(node.name);

        if (symbol == null) {
            throw new SemanticException(
                "Variable '" + node.name + "' no declarada", node
            );
        }

        // Anotar el nodo con el tipo y el sÃ­mbolo resuelto
        node.type = symbol.type;
        node.resolvedSymbol = symbol;

        return symbol.type;
    }

    // â”â”â” VERIFICAR OPERACIONES BINARIAS â”â”â”
    private Type checkBinaryOp(BinaryOpNode node) {
        // PASO 1: Verificar tipos de operandos
        Type leftType = checkExpression(node.left);
        Type rightType = checkExpression(node.right);

        // PASO 2: Verificar segÃºn el operador
        switch (node.operator) {
            case PLUS:
            case MINUS:
            case MULTIPLY:
            case DIVIDE:
            case MODULO:
                return checkArithmeticOp(node, leftType, rightType);

            case EQUALS:
            case NOT_EQUALS:
                return checkEqualityOp(node, leftType, rightType);

            case LESS_THAN:
            case LESS_EQUAL:
            case GREATER_THAN:
            case GREATER_EQUAL:
                return checkComparisonOp(node, leftType, rightType);

            case AND:
            case OR:
                return checkLogicalOp(node, leftType, rightType);

            default:
                throw new SemanticException("Operador desconocido: " + node.operator);
        }
    }

    // â”â”â” OPERADORES ARITMÃ‰TICOS (+, -, *, /, %) â”â”â”
    private Type checkArithmeticOp(BinaryOpNode node, Type left, Type right) {
        // Verificar que ambos operandos sean numÃ©ricos
        if (!left.isNumeric()) {
            throw new SemanticException(
                "Operando izquierdo de '" + node.operator +
                "' debe ser numÃ©rico, se obtuvo " + left, node
            );
        }

        if (!right.isNumeric()) {
            throw new SemanticException(
                "Operando derecho de '" + node.operator +
                "' debe ser numÃ©rico, se obtuvo " + right, node
            );
        }

        // Promover al tipo "mÃ¡s amplio"
        Type resultType = Type.widen(left, right);
        node.type = resultType;

        return resultType;
    }

    // â”â”â” OPERADORES DE IGUALDAD (==, !=) â”â”â”
    private Type checkEqualityOp(BinaryOpNode node, Type left, Type right) {
        // Los tipos deben ser compatibles
        if (!left.isCompatible(right)) {
            throw new SemanticException(
                "No se pueden comparar " + left + " con " + right, node
            );
        }

        node.type = Type.BOOLEAN;
        return Type.BOOLEAN;
    }

    // â”â”â” OPERADORES DE COMPARACIÃ“N (<, <=, >, >=) â”â”â”
    private Type checkComparisonOp(BinaryOpNode node, Type left, Type right) {
        // Ambos deben ser numÃ©ricos
        if (!left.isNumeric() || !right.isNumeric()) {
            throw new SemanticException(
                "Operadores de comparaciÃ³n requieren operandos numÃ©ricos", node
            );
        }

        node.type = Type.BOOLEAN;
        return Type.BOOLEAN;
    }

    // â”â”â” OPERADORES LÃ“GICOS (&&, ||) â”â”â”
    private Type checkLogicalOp(BinaryOpNode node, Type left, Type right) {
        // Ambos deben ser booleanos
        if (!left.isBoolean()) {
            throw new SemanticException(
                "Operando izquierdo de '" + node.operator +
                "' debe ser boolean, se obtuvo " + left, node
            );
        }

        if (!right.isBoolean()) {
            throw new SemanticException(
                "Operando derecho de '" + node.operator +
                "' debe ser boolean, se obtuvo " + right, node
            );
        }

        node.type = Type.BOOLEAN;
        return Type.BOOLEAN;
    }

    // â”â”â” OPERADORES UNARIOS (-, !) â”â”â”
    private Type checkUnaryOp(UnaryOpNode node) {
        Type operandType = checkExpression(node.operand);

        switch (node.operator) {
            case MINUS:
                // -x requiere que x sea numÃ©rico
                if (!operandType.isNumeric()) {
                    throw new SemanticException(
                        "Operador '-' requiere operando numÃ©rico, se obtuvo " +
                        operandType, node
                    );
                }
                node.type = operandType;
                return operandType;

            case NOT:
                // !x requiere que x sea booleano
                if (!operandType.isBoolean()) {
                    throw new SemanticException(
                        "Operador '!' requiere operando boolean, se obtuvo " +
                        operandType, node
                    );
                }
                node.type = Type.BOOLEAN;
                return Type.BOOLEAN;

            default:
                throw new SemanticException("Operador unario desconocido");
        }
    }

    // â”â”â” PROMOCIÃ“N DE TIPOS â”â”â”
    public static Type widen(Type t1, Type t2) {
        // Si uno de los dos es double, el resultado es double
        if (t1.isDouble() || t2.isDouble()) {
            return Type.DOUBLE;
        }

        // Si uno es float, el resultado es float
        if (t1.isFloat() || t2.isFloat()) {
            return Type.FLOAT;
        }

        // Si uno es long, el resultado es long
        if (t1.isLong() || t2.isLong()) {
            return Type.LONG;
        }

        // Si ambos son int o mÃ¡s pequeÃ±os, el resultado es int
        return Type.INT;
    }
}
```

### **Ejemplo paso a paso:**

Analicemos la expresiÃ³n: `5 + 3.14`

```
INICIO: checkExpression(BinaryOpNode(+, 5, 3.14))

1. Identificar que es BinaryOpNode
   â””â”€> checkBinaryOp(node)

2. Verificar operando izquierdo (5)
   â””â”€> checkExpression(NumberNode(5))
   â””â”€> checkNumberNode(NumberNode(5))
   â””â”€> 5 % 1 == 0 â†’ true
   â””â”€> Retorna: Type.INT

3. Verificar operando derecho (3.14)
   â””â”€> checkExpression(NumberNode(3.14))
   â””â”€> checkNumberNode(NumberNode(3.14))
   â””â”€> 3.14 % 1 == 0 â†’ false
   â””â”€> Retorna: Type.DOUBLE

4. Identificar operador: PLUS (aritmÃ©tico)
   â””â”€> checkArithmeticOp(node, INT, DOUBLE)

5. Verificar que left (INT) es numÃ©rico
   â””â”€> INT.isNumeric() â†’ true âœ“

6. Verificar que right (DOUBLE) es numÃ©rico
   â””â”€> DOUBLE.isNumeric() â†’ true âœ“

7. Promover al tipo mÃ¡s amplio
   â””â”€> Type.widen(INT, DOUBLE)
   â””â”€> Uno es DOUBLE â†’ retorna DOUBLE

8. Anotar nodo con tipo resultado
   â””â”€> node.type = DOUBLE

9. Retornar tipo
   â””â”€> return DOUBLE

RESULTADO: 5 + 3.14 tiene tipo DOUBLE âœ“
```

### **Ejemplo con error:**

Analicemos la expresiÃ³n: `5 + "hola"`

```
INICIO: checkExpression(BinaryOpNode(+, 5, "hola"))

1. Identificar que es BinaryOpNode
   â””â”€> checkBinaryOp(node)

2. Verificar operando izquierdo (5)
   â””â”€> checkExpression(NumberNode(5))
   â””â”€> Retorna: Type.INT

3. Verificar operando derecho ("hola")
   â””â”€> checkExpression(StringNode("hola"))
   â””â”€> Retorna: Type.STRING

4. Identificar operador: PLUS (aritmÃ©tico)
   â””â”€> checkArithmeticOp(node, INT, STRING)

5. Verificar que left (INT) es numÃ©rico
   â””â”€> INT.isNumeric() â†’ true âœ“

6. Verificar que right (STRING) es numÃ©rico
   â””â”€> STRING.isNumeric() â†’ false âœ—

7. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "Operando derecho de '+' debe ser numÃ©rico, se obtuvo String"
   )

RESULTADO: âœ— ERROR SEMÃNTICO
Error en lÃ­nea X: Operando derecho de '+' debe ser numÃ©rico, se obtuvo String
```

### **Tabla de verificaciÃ³n de operadores:**

```
OPERADOR | OPERANDOS REQUERIDOS    | TIPO RESULTADO | EJEMPLO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   +     | numÃ©rico + numÃ©rico     | numÃ©rico       | 5 + 3 â†’ int
   -     | numÃ©rico + numÃ©rico     | numÃ©rico       | 5.0 - 2 â†’ double
   *     | numÃ©rico + numÃ©rico     | numÃ©rico       | 3 * 4 â†’ int
   /     | numÃ©rico + numÃ©rico     | numÃ©rico       | 10 / 2 â†’ int
   %     | numÃ©rico + numÃ©rico     | numÃ©rico       | 10 % 3 â†’ int
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ==    | mismo tipo o compatibles| boolean        | 5 == 5 â†’ true
   !=    | mismo tipo o compatibles| boolean        | 5 != 3 â†’ true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   <     | numÃ©rico + numÃ©rico     | boolean        | 5 < 10 â†’ true
   <=    | numÃ©rico + numÃ©rico     | boolean        | 5 <= 5 â†’ true
   >     | numÃ©rico + numÃ©rico     | boolean        | 10 > 5 â†’ true
   >=    | numÃ©rico + numÃ©rico     | boolean        | 5 >= 10 â†’ false
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   &&    | boolean + boolean       | boolean        | true && false â†’ false
   ||    | boolean + boolean       | boolean        | true || false â†’ true
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   !     | boolean                 | boolean        | !true â†’ false
   -     | numÃ©rico                | numÃ©rico       | -5 â†’ -5
```

### **Pregunta de comprensiÃ³n:**

Â¿CuÃ¡l es el tipo de estas expresiones?

```java
5 + 10          // ?
5 + 3.14        // ?
5 < 10          // ?
true && false   // ?
5 + "hola"      // ?
```

**Respuesta:**

```
5 + 10         â†’ int (ambos int)
5 + 3.14       â†’ double (promociÃ³n: int + double â†’ double)
5 < 10         â†’ boolean (comparaciÃ³n siempre retorna boolean)
true && false  â†’ boolean (lÃ³gico siempre retorna boolean)
5 + "hola"     â†’ âœ— ERROR (int + String incompatibles)
```

---

## PÃ¡gina 12: CoerciÃ³n y PromociÃ³n de Tipos - ExplicaciÃ³n Completa

### **Â¿QuÃ© es la CoerciÃ³n de Tipos?**

**CoerciÃ³n** (type coercion) es la conversiÃ³n de un tipo a otro.

**Dos tipos:**
1. **ImplÃ­cita (automÃ¡tica):** El compilador convierte automÃ¡ticamente
2. **ExplÃ­cita (cast):** El programador fuerza la conversiÃ³n

```mermaid
graph LR
    A[CoerciÃ³n de Tipos] --> B[ImplÃ­cita<br/>Widening]
    A --> C[ExplÃ­cita<br/>Narrowing/Cast]

    B --> D["int â†’ double<br/>AutomÃ¡tico<br/>Sin pÃ©rdida"]
    B --> E["char â†’ int<br/>AutomÃ¡tico<br/>Sin pÃ©rdida"]

    C --> F["double â†’ int<br/>Requiere cast<br/>Pierde decimales"]
    C --> G["Object â†’ String<br/>Requiere cast<br/>Puede fallar"]

    style B fill:#c8e6c9,stroke:#388e3c
    style C fill:#fff9c4,stroke:#f9a825
```

### **JerarquÃ­a de promociÃ³n numÃ©rica:**

```
WIDENING (PromociÃ³n implÃ­cita - SEGURA):

byte â†’ short â†’ int â†’ long â†’ float â†’ double
       char â†’

DirecciÃ³n: â†’  SIEMPRE SEGURO (no hay pÃ©rdida de informaciÃ³n)
DirecciÃ³n: â†  REQUIERE CAST (puede haber pÃ©rdida)
```

### **ExplicaciÃ³n visual:**

```
Contenedores de diferentes tamaÃ±os:

byte:   [8 bits]
short:  [16 bits]
int:    [32 bits]
long:   [64 bits]
float:  [32 bits con punto flotante]
double: [64 bits con punto flotante]

WIDENING (agrandar contenedor):
  byte â†’ int
  [pequeÃ±o] â†’ [grande]
  âœ“ Siempre cabe

NARROWING (achicar contenedor):
  int â†’ byte
  [grande] â†’ [pequeÃ±o]
  âœ— Puede no caber
```

### **PromociÃ³n ImplÃ­cita (Widening) - DETALLE:**

#### **Ejemplo 1: int â†’ double**

```java
int x = 5;
double y = x;  // âœ“ PromociÃ³n implÃ­cita
```

**Â¿QuÃ© pasa internamente?**

```
PASO 1: Compilador detecta asignaciÃ³n
  - Variable destino: y (tipo double)
  - Valor fuente: x (tipo int)

PASO 2: Verificar compatibilidad
  - int.isCompatible(double) ?
  - Consultar reglas de promociÃ³n
  - int â†’ double estÃ¡ en la jerarquÃ­a âœ“

PASO 3: ConversiÃ³n automÃ¡tica
  Valor en memoria:
    x (int):    00000000 00000000 00000000 00000101  (5 en binario)
    y (double): 01000000 00010100 00000000... (5.0 en punto flotante)

PASO 4: AsignaciÃ³n completada
  - Sin pÃ©rdida de informaciÃ³n
  - Sin advertencias
```

**ImplementaciÃ³n:**

```java
class Type {
    public boolean canWiden(Type target) {
        // Mismo tipo siempre es compatible
        if (this.equals(target)) {
            return true;
        }

        // Reglas de widening
        if (this.isInt() && target.isDouble()) {
            return true;  // int â†’ double âœ“
        }

        if (this.isInt() && target.isLong()) {
            return true;  // int â†’ long âœ“
        }

        if (this.isChar() && target.isInt()) {
            return true;  // char â†’ int âœ“
        }

        if (this.isFloat() && target.isDouble()) {
            return true;  // float â†’ double âœ“
        }

        // ... mÃ¡s reglas

        return false;  // No se puede promover
    }

    public static Type widen(Type t1, Type t2) {
        // Retornar el tipo "mÃ¡s grande"

        // Si uno es double, resultado es double
        if (t1.isDouble() || t2.isDouble()) {
            return Type.DOUBLE;
        }

        // Si uno es float, resultado es float
        if (t1.isFloat() || t2.isFloat()) {
            return Type.FLOAT;
        }

        // Si uno es long, resultado es long
        if (t1.isLong() || t2.isLong()) {
            return Type.LONG;
        }

        // Si ambos son int o menores, resultado es int
        if (t1.isInt() || t2.isInt()) {
            return Type.INT;
        }

        // Por defecto, el primero
        return t1;
    }
}
```

#### **Ejemplo 2: PromociÃ³n en expresiones**

```java
int a = 5;
double b = 3.14;
double resultado = a + b;  // âœ“ OK
```

**Proceso detallado:**

```
EXPRESIÃ“N: a + b

1. Verificar tipo de 'a'
   â””â”€> lookup("a") â†’ Symbol(a, int)
   â””â”€> Tipo: int

2. Verificar tipo de 'b'
   â””â”€> lookup("b") â†’ Symbol(b, double)
   â””â”€> Tipo: double

3. Verificar operaciÃ³n: int + double
   â””â”€> Ambos son numÃ©ricos âœ“

4. Promover al tipo mÃ¡s amplio
   â””â”€> Type.widen(int, double)
   â””â”€> Retorna: double

5. ConversiÃ³n implÃ­cita de 'a'
   Antes: a = 5 (int)
   DespuÃ©s: a = 5.0 (double temporalmente para la operaciÃ³n)

6. Realizar operaciÃ³n
   5.0 + 3.14 = 8.14

7. Verificar asignaciÃ³n: double = double
   â””â”€> Tipos coinciden âœ“

RESULTADO: resultado = 8.14 (double)
```

### **Cast ExplÃ­cito (Narrowing) - DETALLE:**

#### **Ejemplo 1: double â†’ int (pÃ©rdida de precisiÃ³n)**

```java
double pi = 3.14159;
int truncado = (int) pi;  // Cast explÃ­cito necesario
```

**Â¿QuÃ© pasa internamente?**

```
EXPRESIÃ“N: (int) pi

PASO 1: Sin cast - ERROR
  double pi = 3.14159;
  int truncado = pi;  // âœ— ERROR
  
  RazÃ³n: double NO puede asignarse a int implÃ­citamente
         (pÃ©rdida de informaciÃ³n)

PASO 2: Con cast - OK pero con ADVERTENCIA
  int truncado = (int) pi;  // âœ“ OK
  
  Compilador:
    - Detecta cast explÃ­cito (int)
    - Permite la conversiÃ³n
    - Posible advertencia: "pÃ©rdida de precisiÃ³n"

PASO 3: ConversiÃ³n
  Valor original: 3.14159 (double)
  ConversiÃ³n:     3.14159 â†’ 3 (se eliminan decimales)
  Valor final:    3 (int)

RESULTADO: truncado = 3 (se perdiÃ³ .14159)
```

**ImplementaciÃ³n:**

```java
@Override
public Type visitCastExpression(CastExpressionNode node) {
    // Verificar tipo de la expresiÃ³n
    Type exprType = node.expression.accept(this);

    // Verificar tipo de destino
    Type targetType = node.targetType;

    // Â¿Es widening? (OK sin cast)
    if (exprType.canWiden(targetType)) {
        // Advertencia: cast innecesario
        System.out.println("Advertencia: cast innecesario de " +
                          exprType + " a " + targetType);
    }
    // Â¿Es narrowing? (requiere cast)
    else if (targetType.canNarrow(exprType)) {
        // Advertencia: posible pÃ©rdida de datos
        System.out.println("Advertencia: posible pÃ©rdida de datos al " +
                          "convertir " + exprType + " a " + targetType);
    }
    // Â¿Incompatible totalmente?
    else {
        throw new SemanticException(
            "No se puede convertir " + exprType + " a " + targetType
        );
    }

    node.type = targetType;
    return targetType;
}
```

#### **Ejemplo 2: Cast invÃ¡lido**

```java
String s = "hello";
int n = (int) s;  // âœ— ERROR: cast invÃ¡lido
```

**Proceso:**

```
EXPRESIÃ“N: (int) s

1. Identificar tipo de 's'
   â””â”€> lookup("s") â†’ Symbol(s, String)
   â””â”€> Tipo: String

2. Tipo de destino: int

3. Â¿String puede widening a int?
   â””â”€> String.canWiden(int) â†’ false

4. Â¿String puede narrowing a int?
   â””â”€> String.canNarrow(int) â†’ false

5. Â¿Son compatibles de alguna forma?
   â””â”€> No hay relaciÃ³n entre String e int

6. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "No se puede convertir String a int"
   )

RESULTADO: âœ— ERROR DE COMPILACIÃ“N
```

### **Tabla completa de conversiones:**

```
CONVERSIONES VÃLIDAS:

ORIGEN  | DESTINO | TIPO      | PÃ‰RDIDA | EJEMPLO
â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
byte    | short   | implÃ­cita | no      | byte b = 5; short s = b;
byte    | int     | implÃ­cita | no      | byte b = 5; int i = b;
short   | int     | implÃ­cita | no      | short s = 5; int i = s;
int     | long    | implÃ­cita | no      | int i = 5; long l = i;
int     | double  | implÃ­cita | no      | int i = 5; double d = i;
float   | double  | implÃ­cita | no      | float f = 5.0f; double d = f;
char    | int     | implÃ­cita | no      | char c = 'A'; int i = c;
â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
double  | int     | explÃ­cita | SÃ      | double d = 3.14; int i = (int)d;
long    | int     | explÃ­cita | posible | long l = 5000000000L; int i = (int)l;
int     | byte    | explÃ­cita | posible | int i = 200; byte b = (byte)i;
int     | char    | explÃ­cita | posible | int i = 65; char c = (char)i;
â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
String  | int     | INVÃLIDO  | N/A     | âœ— No hay conversiÃ³n
int     | String  | INVÃLIDO  | N/A     | âœ— Usar String.valueOf(i)
```

### **Pregunta de comprensiÃ³n:**

Clasifica estas conversiones:

```java
int a = 5;
double b = a;       // Â¿ImplÃ­cita o explÃ­cita? Â¿VÃ¡lida?

double c = 3.14;
int d = c;          // Â¿ImplÃ­cita o explÃ­cita? Â¿VÃ¡lida?

double e = 3.14;
int f = (int) e;    // Â¿ImplÃ­cita o explÃ­cita? Â¿VÃ¡lida?

String s = "hello";
int g = (int) s;    // Â¿ImplÃ­cita o explÃ­cita? Â¿VÃ¡lida?
```

**Respuesta:**

```
double b = a;    â†’ ImplÃ­cita, âœ“ VÃLIDA (int â†’ double, widening)
int d = c;       â†’ âœ— INVÃLIDA (double â†’ int requiere cast)
int f = (int) e; â†’ ExplÃ­cita, âœ“ VÃLIDA (cast correcto, pierde .14)
int g = (int) s; â†’ âœ— INVÃLIDA (String e int incompatibles, incluso con cast)
```

---


## PÃ¡gina 13: Errores SemÃ¡nticos Comunes - CatÃ¡logo Completo

### **CatÃ¡logo de Errores SemÃ¡nticos con Ejemplos:**

#### **Error 1: Variable no declarada**

**CÃ³digo:**
```java
x = 5;  // âœ— ERROR
```

**AnÃ¡lisis paso a paso:**

```
1. Encontrar AssignmentNode(name="x", value=5)
2. Buscar variable 'x' en tabla de sÃ­mbolos
   â””â”€> symbolTable.lookup("x")
   â””â”€> Retorna: null (no existe)
3. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException("Variable 'x' no declarada")
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 1, columna 1:
  Variable 'x' no declarada
  x = 5;
  ^
```

**SoluciÃ³n:**
```java
int x;  // Declarar primero
x = 5;  // Ahora sÃ­ âœ“
```

#### **Error 2: Variable ya declarada (RedeclaraciÃ³n)**

**CÃ³digo:**
```java
int x = 5;
int x = 10;  // âœ— ERROR
```

**AnÃ¡lisis paso a paso:**

```
LÃ­nea 1: int x = 5;
  1. existsInCurrentScope("x") â†’ false
  2. insert(Symbol("x", int, 5)) â†’ OK
  Tabla: {x: int}

LÃ­nea 2: int x = 10;
  1. existsInCurrentScope("x") â†’ true âœ—
  2. LANZAR EXCEPCIÃ“N
     â””â”€> throw new SemanticException(
         "Variable 'x' ya declarada en lÃ­nea 1"
     )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 2, columna 5:
  Variable 'x' ya declarada en lÃ­nea 1
  int x = 10;
      ^
```

**SoluciÃ³n:**
```java
int x = 5;
x = 10;  // AsignaciÃ³n, no declaraciÃ³n âœ“
```

#### **Error 3: Incompatibilidad de tipos en asignaciÃ³n**

**CÃ³digo:**
```java
int x = "hello";  // âœ— ERROR
```

**AnÃ¡lisis paso a paso:**

```
1. DeclaraciÃ³n: int x = "hello"
2. Tipo declarado: int
3. Verificar tipo de inicializador
   â””â”€> checkExpression(StringNode("hello"))
   â””â”€> Retorna: Type.STRING
4. Verificar compatibilidad: int = String
   â””â”€> int.isCompatible(String) â†’ false
5. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "No se puede inicializar int con String"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 1, columna 9:
  No se puede asignar String a variable de tipo int
  int x = "hello";
          ^^^^^^^
```

**SoluciÃ³n:**
```java
String x = "hello";  // Declarar como String âœ“
// O
int x = 5;  // Usar valor compatible âœ“
```

#### **Error 4: OperaciÃ³n invÃ¡lida para tipos**

**CÃ³digo:**
```java
boolean b = true;
int x = b + 5;  // âœ— ERROR
```

**AnÃ¡lisis paso a paso:**

```
1. ExpresiÃ³n: b + 5
2. Tipo de 'b'
   â””â”€> lookup("b") â†’ Symbol(b, boolean)
   â””â”€> Tipo: boolean
3. Tipo de '5'
   â””â”€> NumberNode(5) â†’ Type.INT
4. Verificar operaciÃ³n: boolean + int
   â””â”€> Operador + requiere operandos numÃ©ricos
   â””â”€> boolean.isNumeric() â†’ false âœ—
5. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "Operador '+' requiere operandos numÃ©ricos"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 2, columna 9:
  Operador '+' requiere operandos numÃ©ricos, se obtuvo boolean
  int x = b + 5;
          ^
```

**SoluciÃ³n:**
```java
boolean b = true;
int x = (b ? 1 : 0) + 5;  // Convertir boolean a int âœ“
```

#### **Error 5: NÃºmero incorrecto de argumentos en llamada**

**CÃ³digo:**
```java
int suma(int a, int b) {
    return a + b;
}
int x = suma(5);  // âœ— ERROR: faltan argumentos
```

**AnÃ¡lisis paso a paso:**

```
1. Declarar funciÃ³n suma(int, int) â†’ int
   â””â”€> insert(Symbol("suma", FunctionType(int, [int, int])))
   Tabla: {suma: (int, int) â†’ int}

2. Llamada: suma(5)
   â””â”€> lookup("suma") â†’ Symbol(suma, FunctionType)
   â””â”€> FunctionType.parameterTypes.size() = 2
   â””â”€> Argumentos proporcionados = 1
3. Verificar cantidad: 2 â‰  1 âœ—
4. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "FunciÃ³n 'suma' espera 2 argumentos, se recibieron 1"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 4, columna 9:
  FunciÃ³n 'suma' espera 2 argumentos, se recibieron 1
  int x = suma(5);
          ^^^^
```

**SoluciÃ³n:**
```java
int x = suma(5, 10);  // Pasar ambos argumentos âœ“
```

#### **Error 6: Tipo incorrecto de argumento**

**CÃ³digo:**
```java
int suma(int a, int b) {
    return a + b;
}
int x = suma(5, "hola");  // âœ— ERROR: tipo incorrecto
```

**AnÃ¡lisis paso a paso:**

```
1. FunciÃ³n: suma(int, int) â†’ int
2. Llamada: suma(5, "hola")
3. Verificar argumento 1:
   â””â”€> Tipo: int (esperado int) âœ“
4. Verificar argumento 2:
   â””â”€> Tipo: String (esperado int) âœ—
   â””â”€> String.isCompatible(int) â†’ false
5. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "Argumento 2: se esperaba int, se obtuvo String"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 4, columna 18:
  Argumento 2: se esperaba int, se obtuvo String
  int x = suma(5, "hola");
                  ^^^^^^
```

**SoluciÃ³n:**
```java
int x = suma(5, 10);  // Pasar int, no String âœ“
```

#### **Error 7: Tipo de retorno incorrecto**

**CÃ³digo:**
```java
int calcular() {
    return "hello";  // âœ— ERROR
}
```

**AnÃ¡lisis paso a paso:**

```
1. FunciÃ³n declarada: int calcular()
   â””â”€> currentReturnType = Type.INT
2. Return statement: return "hello";
3. Tipo de expresiÃ³n retornada:
   â””â”€> checkExpression(StringNode("hello"))
   â””â”€> Retorna: Type.STRING
4. Verificar compatibilidad: int = String
   â””â”€> String.isCompatible(int) â†’ false âœ—
5. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "Se esperaba retorno de tipo int, se obtuvo String"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 2, columna 12:
  Se esperaba retorno de tipo int, se obtuvo String
      return "hello";
             ^^^^^^^
```

**SoluciÃ³n:**
```java
int calcular() {
    return 42;  // Retornar int âœ“
}
// O cambiar tipo de retorno:
String calcular() {
    return "hello";  // âœ“
}
```

#### **Error 8: Break/Continue fuera de loop**

**CÃ³digo:**
```java
void foo() {
    break;  // âœ— ERROR
}
```

**AnÃ¡lisis paso a paso:**

```
1. Entrar funciÃ³n foo()
   â””â”€> currentScope = foo
   â””â”€> inLoop = false
2. Encontrar BreakNode
3. Verificar contexto
   â””â”€> if (!inLoop) âœ—
4. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "break debe estar dentro de un loop"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 2, columna 5:
  'break' debe estar dentro de un loop
      break;
      ^^^^^
```

**SoluciÃ³n:**
```java
void foo() {
    while (true) {
        break;  // Ahora sÃ­ estÃ¡ en loop âœ“
    }
}
```

#### **Error 9: Return fuera de funciÃ³n**

**CÃ³digo:**
```java
return 5;  // âœ— ERROR: return en scope global
```

**AnÃ¡lisis paso a paso:**

```
1. Scope actual: GLOBAL
   â””â”€> currentReturnType = null
2. Encontrar ReturnNode
3. Verificar contexto
   â””â”€> if (currentReturnType == null) âœ—
4. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "return debe estar dentro de una funciÃ³n"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 1, columna 1:
  'return' debe estar dentro de una funciÃ³n
  return 5;
  ^^^^^^
```

**SoluciÃ³n:**
```java
int foo() {
    return 5;  // Dentro de funciÃ³n âœ“
}
```

#### **Error 10: Acceso a campo inexistente**

**CÃ³digo:**
```java
class Point {
    int x;
    int y;
}
Point p = new Point();
int z = p.z;  // âœ— ERROR: campo 'z' no existe
```

**AnÃ¡lisis paso a paso:**

```
1. Acceso: p.z
2. Tipo de 'p'
   â””â”€> lookup("p") â†’ Symbol(p, Point)
   â””â”€> Tipo: ClassType(Point)
3. Buscar campo 'z' en Point
   â””â”€> Point.fields.get("z") â†’ null
4. LANZAR EXCEPCIÃ“N
   â””â”€> throw new SemanticException(
       "La clase Point no tiene campo 'z'"
   )
```

**Mensaje de error:**
```
Error semÃ¡ntico en lÃ­nea 6, columna 11:
  La clase Point no tiene campo 'z'
  int z = p.z;
            ^
```

**SoluciÃ³n:**
```java
int z = p.x;  // Usar campo existente âœ“
// O agregar campo 'z' a la clase
```

### **Clase SemanticException:**

```java
class SemanticException extends Exception {
    int lineNumber;
    int columnNumber;
    String message;
    ASTNode node;  // Nodo donde ocurriÃ³ el error

    public SemanticException(String message, ASTNode node) {
        super(message);
        this.message = message;
        this.lineNumber = node.lineNumber;
        this.columnNumber = node.columnNumber;
        this.node = node;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        // LÃ­nea del error
        sb.append("Error semÃ¡ntico en lÃ­nea ")
          .append(lineNumber)
          .append(", columna ")
          .append(columnNumber)
          .append(":\n");

        // Mensaje descriptivo
        sb.append("  ").append(message).append("\n");

        // Mostrar lÃ­nea de cÃ³digo (si estÃ¡ disponible)
        if (node.sourceLine != null) {
            sb.append("  ").append(node.sourceLine).append("\n");

            // Indicador visual (^)
            sb.append("  ");
            for (int i = 0; i < columnNumber - 1; i++) {
                sb.append(" ");
            }
            sb.append("^\n");
        }

        return sb.toString();
    }
}
```

### **Formato de mensaje de error completo:**

```
Error semÃ¡ntico en lÃ­nea 15, columna 12: Variable 'contador' no declarada
    contador = contador + 1;
               ^^^^^^^^
Sugerencia: Â¿QuizÃ¡s quisiste decir 'count'?
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© errores hay en este cÃ³digo?

```java
int x = 5;
int x = 10;
y = x + "hola";
int suma(int a) {
    return a + b;
}
```

**Respuesta:**

```
LÃ­nea 2: Variable 'x' ya declarada en lÃ­nea 1
LÃ­nea 3: Variable 'y' no declarada
LÃ­nea 3: Operador '+' incompatible: int + String
LÃ­nea 5: Variable 'b' no declarada
```

---


## PÃ¡gina 14: PatrÃ³n Visitor - Recorriendo el AST en Detalle

### **Â¿Por quÃ© necesitamos el patrÃ³n Visitor?**

**Problema:** Queremos agregar operaciones al AST sin modificar las clases de los nodos.

**Ejemplo del problema:**

```java
// Sin Visitor - MALO
class ExpressionNode {
    // Si queremos agregar type checking, modificamos la clase
    public Type typeCheck() { ... }
    
    // Si luego queremos generar cÃ³digo, modificamos de nuevo
    public String generateCode() { ... }
    
    // Si despuÃ©s queremos pretty printing, modificamos de nuevo
    public String prettyPrint() { ... }
    
    // âœ— Cada nueva operaciÃ³n requiere modificar TODAS las clases
}
```

**SoluciÃ³n con Visitor:**

```java
// Con Visitor - BUENO
class ExpressionNode {
    // Un solo mÃ©todo que NO cambia
    public <T> T accept(ASTVisitor<T> visitor) {
        return visitor.visitExpressionNode(this);
    }
}

// Agregar operaciones SIN modificar las clases AST
class TypeCheckVisitor implements ASTVisitor<Type> { ... }
class CodeGenVisitor implements ASTVisitor<String> { ... }
class PrettyPrintVisitor implements ASTVisitor<String> { ... }
```

### **Diagrama de componentes del patrÃ³n Visitor:**

```mermaid
classDiagram
    class ASTVisitor {
        <<interface>>
        +visitProgramNode(node) Type
        +visitDeclarationNode(node) Type
        +visitAssignmentNode(node) Type
        +visitBinaryOpNode(node) Type
        +visitIdentifierNode(node) Type
        +visitNumberNode(node) Type
    }

    class SemanticAnalyzer {
        -symbolTable SymbolTable
        -errors List~Error~
        +analyze(program)
        +visitProgramNode(node) Type
        +visitDeclarationNode(node) Type
    }

    class ASTNode {
        <<abstract>>
        +lineNumber int
        +columnNumber int
        +accept(visitor) T
    }

    class ProgramNode {
        +statements List~Statement~
        +accept(visitor) T
    }

    class DeclarationNode {
        +type Type
        +name String
        +initializer Expression
        +accept(visitor) T
    }

    class BinaryOpNode {
        +left Expression
        +operator Operator
        +right Expression
        +accept(visitor) T
    }

    ASTVisitor <|.. SemanticAnalyzer
    ASTNode <|-- ProgramNode
    ASTNode <|-- DeclarationNode
    ASTNode <|-- BinaryOpNode

    ProgramNode ..> ASTVisitor : accept()
    DeclarationNode ..> ASTVisitor : accept()
    BinaryOpNode ..> ASTVisitor : accept()
```

### **ImplementaciÃ³n completa paso a paso:**

#### **Paso 1: Definir la interfaz Visitor**

```java
interface ASTVisitor<T> {
    // Un mÃ©todo por cada tipo de nodo

    // Statements
    T visitProgramNode(ProgramNode node);
    T visitDeclarationNode(DeclarationNode node);
    T visitAssignmentNode(AssignmentNode node);
    T visitIfStatementNode(IfStatementNode node);
    T visitWhileStatementNode(WhileStatementNode node);
    T visitReturnNode(ReturnNode node);
    T visitBreakNode(BreakNode node);
    T visitContinueNode(ContinueNode node);

    // Expressions
    T visitBinaryOpNode(BinaryOpNode node);
    T visitUnaryOpNode(UnaryOpNode node);
    T visitFunctionCallNode(FunctionCallNode node);
    T visitArrayAccessNode(ArrayAccessNode node);

    // Literals
    T visitIdentifierNode(IdentifierNode node);
    T visitNumberNode(NumberNode node);
    T visitBooleanNode(BooleanNode node);
    T visitStringNode(StringNode node);
}
```

**ExplicaciÃ³n del genÃ©rico `<T>`:**

```
T = Tipo de retorno de cada mÃ©todo visit

Ejemplos:
- TypeCheckVisitor implements ASTVisitor<Type>
  â†’ Cada mÃ©todo retorna Type
  
- CodeGenVisitor implements ASTVisitor<String>
  â†’ Cada mÃ©todo retorna String (cÃ³digo generado)
  
- PrettyPrintVisitor implements ASTVisitor<String>
  â†’ Cada mÃ©todo retorna String (cÃ³digo formateado)
```

#### **Paso 2: Implementar accept() en cada nodo**

```java
// Clase base
abstract class ASTNode {
    int lineNumber;
    int columnNumber;
    String sourceLine;  // LÃ­nea de cÃ³digo fuente (para errores)

    // MÃ©todo abstracto que cada subclase implementa
    abstract <T> T accept(ASTVisitor<T> visitor);
}

// Nodo de programa
class ProgramNode extends ASTNode {
    List<StatementNode> statements;

    public ProgramNode(List<StatementNode> statements) {
        this.statements = statements;
    }

    @Override
    public <T> T accept(ASTVisitor<T> visitor) {
        // Delegar al visitor
        return visitor.visitProgramNode(this);
    }
}

// Nodo de declaraciÃ³n
class DeclarationNode extends StatementNode {
    Type declaredType;
    String name;
    ExpressionNode initializer;

    @Override
    public <T> T accept(ASTVisitor<T> visitor) {
        return visitor.visitDeclarationNode(this);
    }
}

// Nodo de operaciÃ³n binaria
class BinaryOpNode extends ExpressionNode {
    ExpressionNode left;
    Operator operator;
    ExpressionNode right;
    Type type;  // Se llena durante el anÃ¡lisis semÃ¡ntico

    @Override
    public <T> T accept(ASTVisitor<T> visitor) {
        return visitor.visitBinaryOpNode(this);
    }
}

// ... mÃ¡s nodos
```

**PatrÃ³n que se repite:**

```java
@Override
public <T> T accept(ASTVisitor<T> visitor) {
    return visitor.visitXXXNode(this);
    //               ^^^
    //               Nombre del mÃ©todo correspondiente
    //                              ^^^^
    //                              Pasar THIS (el nodo actual)
}
```

#### **Paso 3: Implementar el Visitor concreto (SemanticAnalyzer)**

```java
class SemanticAnalyzer implements ASTVisitor<Type> {
    private SymbolTable symbolTable;
    private List<SemanticException> errors;

    public SemanticAnalyzer() {
        this.symbolTable = new SymbolTable(null);
        this.errors = new ArrayList<>();
    }

    // â”â”â” MÃ‰TODO PRINCIPAL â”â”â”
    public void analyze(ProgramNode program) {
        try {
            program.accept(this);  // Iniciar recorrido
        } catch (SemanticException e) {
            errors.add(e);
        }
    }

    // â”â”â” IMPLEMENTAR CADA MÃ‰TODO VISIT â”â”â”

    @Override
    public Type visitProgramNode(ProgramNode node) {
        // Recorrer todos los statements del programa
        for (StatementNode stmt : node.statements) {
            stmt.accept(this);  // RecursiÃ³n: visitar cada statement
        }
        return null;
    }

    @Override
    public Type visitDeclarationNode(DeclarationNode node) {
        // 1. Verificar que no existe en scope actual
        if (symbolTable.existsInCurrentScope(node.name)) {
            errors.add(new SemanticException(
                "Variable '" + node.name + "' ya declarada", node
            ));
            return null;
        }

        // 2. Verificar tipo del inicializador (si existe)
        Type initType = null;
        if (node.initializer != null) {
            initType = node.initializer.accept(this);  // RecursiÃ³n

            // Verificar compatibilidad
            if (!initType.isCompatible(node.declaredType)) {
                errors.add(new SemanticException(
                    "No se puede inicializar " + node.declaredType +
                    " con " + initType, node
                ));
            }
        }

        // 3. Insertar en tabla de sÃ­mbolos
        Symbol symbol = new Symbol(
            node.name,
            node.declaredType,
            Scope.CURRENT,
            node.lineNumber
        );
        symbolTable.insert(symbol);

        return node.declaredType;
    }

    @Override
    public Type visitBinaryOpNode(BinaryOpNode node) {
        // 1. Verificar operando izquierdo
        Type leftType = node.left.accept(this);  // RecursiÃ³n

        // 2. Verificar operando derecho
        Type rightType = node.right.accept(this);  // RecursiÃ³n

        // 3. Verificar que la operaciÃ³n es vÃ¡lida
        switch (node.operator) {
            case PLUS:
            case MINUS:
            case MULTIPLY:
            case DIVIDE:
                // Ambos deben ser numÃ©ricos
                if (!leftType.isNumeric() || !rightType.isNumeric()) {
                    errors.add(new SemanticException(
                        "Operador aritmÃ©tico requiere operandos numÃ©ricos", node
                    ));
                    return Type.ERROR;
                }
                // Promover al tipo mÃ¡s amplio
                Type resultType = Type.widen(leftType, rightType);
                node.type = resultType;
                return resultType;

            case EQUALS:
            case NOT_EQUALS:
                // Deben ser compatibles
                if (!leftType.isCompatible(rightType)) {
                    errors.add(new SemanticException(
                        "No se pueden comparar " + leftType + " con " + rightType, node
                    ));
                    return Type.ERROR;
                }
                node.type = Type.BOOLEAN;
                return Type.BOOLEAN;

            // ... mÃ¡s operadores

            default:
                return Type.ERROR;
        }
    }

    @Override
    public Type visitIdentifierNode(IdentifierNode node) {
        // Buscar variable en tabla de sÃ­mbolos
        Symbol symbol = symbolTable.lookup(node.name);

        if (symbol == null) {
            errors.add(new SemanticException(
                "Variable '" + node.name + "' no declarada", node
            ));
            return Type.ERROR;
        }

        // Anotar nodo con tipo y sÃ­mbolo resuelto
        node.type = symbol.type;
        node.resolvedSymbol = symbol;

        return symbol.type;
    }

    @Override
    public Type visitNumberNode(NumberNode node) {
        // Determinar si es int o double
        if (node.value % 1 == 0) {
            node.type = Type.INT;
            return Type.INT;
        } else {
            node.type = Type.DOUBLE;
            return Type.DOUBLE;
        }
    }

    // ... mÃ¡s mÃ©todos visit
}
```

### **Flujo de ejecuciÃ³n con Visitor:**

```mermaid
sequenceDiagram
    participant Main
    participant SA as SemanticAnalyzer
    participant PN as ProgramNode
    participant DN as DeclarationNode
    participant BO as BinaryOpNode
    participant ID as IdentifierNode

    Main->>SA: analyze(programNode)
    SA->>PN: programNode.accept(this)
    PN->>SA: visitProgramNode(this)

    loop Por cada statement
        SA->>DN: statement.accept(this)
        DN->>SA: visitDeclarationNode(this)
        
        alt Tiene inicializador
            SA->>BO: initializer.accept(this)
            BO->>SA: visitBinaryOpNode(this)
            SA->>ID: left.accept(this)
            ID->>SA: visitIdentifierNode(this)
            SA-->>BO: Type.INT
            BO-->>SA: Type.INT
        end
        
        SA->>SA: symbolTable.insert(symbol)
        SA-->>PN: Type
    end

    PN-->>SA: null
    SA-->>Main: AnÃ¡lisis completo
```

### **Ejemplo paso a paso:**

CÃ³digo:
```java
int x = 5;
int y = x + 10;
```

**Traza completa del Visitor:**

```
1. Main.analyze(programNode)
2. programNode.accept(semanticAnalyzer)
3. semanticAnalyzer.visitProgramNode(programNode)
4. Loop: por cada statement

   â”â”â” STATEMENT 1: int x = 5; â”â”â”
   
   5. statement[0].accept(semanticAnalyzer)
   6. declarationNode.accept(semanticAnalyzer)
   7. semanticAnalyzer.visitDeclarationNode(declarationNode)
   8.   - Verificar que 'x' no existe: OK
   9.   - initializer.accept(semanticAnalyzer)
   10.  - numberNode(5).accept(semanticAnalyzer)
   11.  - semanticAnalyzer.visitNumberNode(numberNode(5))
   12.  - Retorna: Type.INT
   13.  - Verificar compatibilidad: int = int âœ“
   14.  - Insert Symbol('x', INT) en tabla
   15. Retorna: Type.INT

   â”â”â” STATEMENT 2: int y = x + 10; â”â”â”
   
   16. statement[1].accept(semanticAnalyzer)
   17. declarationNode.accept(semanticAnalyzer)
   18. semanticAnalyzer.visitDeclarationNode(declarationNode)
   19.   - Verificar que 'y' no existe: OK
   20.   - initializer.accept(semanticAnalyzer)
   21.   - binaryOpNode(+).accept(semanticAnalyzer)
   22.   - semanticAnalyzer.visitBinaryOpNode(binaryOpNode)
   23.   - left.accept(semanticAnalyzer)
   24.   - identifierNode('x').accept(semanticAnalyzer)
   25.   - semanticAnalyzer.visitIdentifierNode(identifierNode)
   26.     - lookup('x') â†’ Symbol(x, INT) âœ“
   27.   - Retorna: Type.INT
   28.   - right.accept(semanticAnalyzer)
   29.   - numberNode(10).accept(semanticAnalyzer)
   30.   - Retorna: Type.INT
   31.   - Verificar operaciÃ³n: INT + INT âœ“
   32.   - Type.widen(INT, INT) â†’ INT
   33.   - node.type = INT
   34.   - Retorna: Type.INT
   35.   - Verificar compatibilidad: int = int âœ“
   36.   - Insert Symbol('y', INT) en tabla
   37. Retorna: Type.INT

38. Fin del loop
39. Retorna: null
40. AnÃ¡lisis completo âœ“
```

### **Ventajas del patrÃ³n Visitor:**

```
1. SEPARACIÃ“N DE CONCERNS:
   - Estructura del AST (nodos) â†’ NO cambia
   - Operaciones sobre el AST (visitors) â†’ FÃ¡cil agregar

2. FÃCIL AGREGAR OPERACIONES:
   - Nueva operaciÃ³n = Nueva clase Visitor
   - NO hay que modificar clases AST existentes

3. REUSABILIDAD:
   - El mismo AST sirve para:
     * Type checking
     * Code generation
     * Pretty printing
     * OptimizaciÃ³n
     * etc.

4. POLIMORFISMO:
   - Un solo mÃ©todo accept() en cada nodo
   - Comportamiento especÃ­fico delegado al visitor
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© ventaja tiene el patrÃ³n Visitor sobre agregar mÃ©todos directamente a los nodos?

**Respuesta:**

```
SIN Visitor:
  - Agregar nueva operaciÃ³n â†’ modificar TODAS las clases de nodos
  - Mezcla estructura con operaciones
  - DifÃ­cil de mantener

CON Visitor:
  - Agregar nueva operaciÃ³n â†’ crear UNA nueva clase Visitor
  - Estructura separada de operaciones
  - FÃ¡cil de mantener y extender
```

---

## PÃ¡gina 15: Ejemplo Completo Paso a Paso - Programa Real

### **CÃ³digo de ejemplo completo:**

```java
int x = 5;
int y = 10;
if (x < y) {
    int z = x + y;
    x = z;
}
y = x + 1;
```

### **Paso 1: AST generado por el parser**

```
ProgramNode
â”œâ”€â”€ VariableDeclarationNode
â”‚   â”œâ”€â”€ type: int
â”‚   â”œâ”€â”€ name: "x"
â”‚   â””â”€â”€ initializer: NumberNode(5)
â”œâ”€â”€ VariableDeclarationNode
â”‚   â”œâ”€â”€ type: int
â”‚   â”œâ”€â”€ name: "y"
â”‚   â””â”€â”€ initializer: NumberNode(10)
â”œâ”€â”€ IfStatementNode
â”‚   â”œâ”€â”€ condition: BinaryOpNode
â”‚   â”‚   â”œâ”€â”€ left: IdentifierNode("x")
â”‚   â”‚   â”œâ”€â”€ operator: <
â”‚   â”‚   â””â”€â”€ right: IdentifierNode("y")
â”‚   â”œâ”€â”€ thenBranch: BlockNode
â”‚   â”‚   â”œâ”€â”€ VariableDeclarationNode
â”‚   â”‚   â”‚   â”œâ”€â”€ type: int
â”‚   â”‚   â”‚   â”œâ”€â”€ name: "z"
â”‚   â”‚   â”‚   â””â”€â”€ initializer: BinaryOpNode
â”‚   â”‚   â”‚       â”œâ”€â”€ left: IdentifierNode("x")
â”‚   â”‚   â”‚       â”œâ”€â”€ operator: +
â”‚   â”‚   â”‚       â””â”€â”€ right: IdentifierNode("y")
â”‚   â”‚   â””â”€â”€ AssignmentNode
â”‚   â”‚       â”œâ”€â”€ name: "x"
â”‚   â”‚       â””â”€â”€ value: IdentifierNode("z")
â”‚   â””â”€â”€ elseBranch: null
â””â”€â”€ AssignmentNode
    â”œâ”€â”€ name: "y"
    â””â”€â”€ value: BinaryOpNode
        â”œâ”€â”€ left: IdentifierNode("x")
        â”œâ”€â”€ operator: +
        â””â”€â”€ right: NumberNode(1)
```

### **Paso 2: AnÃ¡lisis semÃ¡ntico lÃ­nea por lÃ­nea**

#### **LÃ­nea 1: `int x = 5;`**

```
INICIO ANÃLISIS LÃNEA 1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Nodo: VariableDeclarationNode(type=int, name="x", initializer=NumberNode(5))

PASO 1: Visitar VariableDeclarationNode
  â””â”€> semanticAnalyzer.visitDeclarationNode(node)

PASO 2: Verificar si 'x' ya existe en scope actual
  â””â”€> symbolTable.existsInCurrentScope("x")
  â””â”€> Retorna: false (no existe)
  â””â”€> âœ“ OK

PASO 3: Verificar tipo del inicializador
  â””â”€> node.initializer.accept(this)
  â””â”€> numberNode(5).accept(this)
  â””â”€> semanticAnalyzer.visitNumberNode(NumberNode(5))
  â””â”€> 5 % 1 == 0 â†’ true
  â””â”€> numberNode.type = Type.INT
  â””â”€> Retorna: Type.INT

PASO 4: Verificar compatibilidad de tipos
  â””â”€> declaredType: int
  â””â”€> initType: int
  â””â”€> int.isCompatible(int) â†’ true
  â””â”€> âœ“ OK

PASO 5: Insertar en tabla de sÃ­mbolos
  â””â”€> symbol = Symbol("x", Type.INT, Scope.GLOBAL, lÃ­nea=1)
  â””â”€> symbolTable.insert(symbol)
  â””â”€> âœ“ Insertado

ESTADO DESPUÃ‰S DE LÃNEA 1:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Tabla de SÃ­mbolos (Global):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nombre â”‚ Tipo â”‚ Scope  â”‚ Valor â”‚ LÃ­nea â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x      â”‚ int  â”‚ global â”‚ 5     â”‚ 1     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

AST Anotado:
  VariableDeclarationNode(name="x") [type=int âœ“]
    â””â”€ NumberNode(5) [type=int âœ“]

Errores: []
```

#### **LÃ­nea 2: `int y = 10;`**

```
INICIO ANÃLISIS LÃNEA 2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Nodo: VariableDeclarationNode(type=int, name="y", initializer=NumberNode(10))

PASO 1: Visitar VariableDeclarationNode
  â””â”€> semanticAnalyzer.visitDeclarationNode(node)

PASO 2: Verificar si 'y' ya existe
  â””â”€> symbolTable.existsInCurrentScope("y")
  â””â”€> Retorna: false
  â””â”€> âœ“ OK

PASO 3: Verificar tipo del inicializador
  â””â”€> NumberNode(10).accept(this)
  â””â”€> 10 % 1 == 0 â†’ true
  â””â”€> Retorna: Type.INT

PASO 4: Verificar compatibilidad
  â””â”€> int.isCompatible(int) â†’ true
  â””â”€> âœ“ OK

PASO 5: Insertar en tabla
  â””â”€> Symbol("y", Type.INT, Scope.GLOBAL, lÃ­nea=2)
  â””â”€> âœ“ Insertado

ESTADO DESPUÃ‰S DE LÃNEA 2:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Tabla de SÃ­mbolos (Global):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nombre â”‚ Tipo â”‚ Scope  â”‚ Valor â”‚ LÃ­nea â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x      â”‚ int  â”‚ global â”‚ 5     â”‚ 1     â”‚
â”‚ y      â”‚ int  â”‚ global â”‚ 10    â”‚ 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

Errores: []
```

#### **LÃ­nea 3: `if (x < y) {`**

```
INICIO ANÃLISIS LÃNEA 3
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Nodo: IfStatementNode(condition=BinaryOpNode(<, x, y))

PASO 1: Visitar IfStatementNode
  â””â”€> semanticAnalyzer.visitIfStatementNode(node)

PASO 2: Verificar tipo de la condiciÃ³n
  â””â”€> node.condition.accept(this)
  â””â”€> binaryOpNode(<).accept(this)
  â””â”€> semanticAnalyzer.visitBinaryOpNode(node)

PASO 3: Verificar operando izquierdo (x)
  â””â”€> node.left.accept(this)
  â””â”€> identifierNode("x").accept(this)
  â””â”€> semanticAnalyzer.visitIdentifierNode(identifierNode)
  â””â”€> symbolTable.lookup("x")
  â””â”€> Encontrado: Symbol("x", Type.INT) âœ“
  â””â”€> identifierNode.type = Type.INT
  â””â”€> identifierNode.resolvedSymbol = Symbol("x", ...)
  â””â”€> Retorna: Type.INT

PASO 4: Verificar operando derecho (y)
  â””â”€> node.right.accept(this)
  â””â”€> identifierNode("y").accept(this)
  â””â”€> symbolTable.lookup("y")
  â””â”€> Encontrado: Symbol("y", Type.INT) âœ“
  â””â”€> Retorna: Type.INT

PASO 5: Verificar operaciÃ³n: INT < INT
  â””â”€> Operador: < (comparaciÃ³n)
  â””â”€> leftType.isNumeric() â†’ true âœ“
  â””â”€> rightType.isNumeric() â†’ true âœ“
  â””â”€> binaryOpNode.type = Type.BOOLEAN
  â””â”€> Retorna: Type.BOOLEAN

PASO 6: Verificar que la condiciÃ³n es booleana
  â””â”€> conditionType.isBoolean() â†’ true âœ“

ESTADO EN LÃNEA 3:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

AST Anotado:
  IfStatementNode [âœ“]
    â””â”€ condition: BinaryOpNode(<) [type=boolean âœ“]
        â”œâ”€ IdentifierNode("x") [type=int âœ“, resolvedTo=Symbol(x)]
        â””â”€ IdentifierNode("y") [type=int âœ“, resolvedTo=Symbol(y)]

Errores: []
```

#### **LÃ­nea 4: `int z = x + y;` (dentro del if)**

```
INICIO ANÃLISIS LÃNEA 4
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Contexto: Dentro del bloque if
Scope actual: BLOQUE IF (hijo de global)

PASO 1: Crear nuevo scope para el bloque if
  â””â”€> symbolTableIf = new SymbolTable(symbolTableGlobal)
  â””â”€> Cambiar scope actual: symbolTable = symbolTableIf

Nodo: VariableDeclarationNode(type=int, name="z", initializer=BinaryOpNode(+, x, y))

PASO 2: Visitar VariableDeclarationNode
  â””â”€> semanticAnalyzer.visitDeclarationNode(node)

PASO 3: Verificar si 'z' ya existe en scope ACTUAL (bloque if)
  â””â”€> symbolTableIf.existsInCurrentScope("z")
  â””â”€> Retorna: false (no existe en bloque if)
  â””â”€> âœ“ OK

PASO 4: Verificar tipo del inicializador (x + y)
  â””â”€> binaryOpNode(+).accept(this)
  â””â”€> semanticAnalyzer.visitBinaryOpNode(node)

PASO 5: Verificar operando izquierdo (x)
  â””â”€> identifierNode("x").accept(this)
  â””â”€> symbolTable.lookup("x")
  â””â”€> BÃºsqueda en symbolTableIf: no encontrado
  â””â”€> BÃºsqueda en parent (symbolTableGlobal): âœ“ Encontrado
  â””â”€> Retorna: Type.INT

PASO 6: Verificar operando derecho (y)
  â””â”€> identifierNode("y").accept(this)
  â””â”€> symbolTable.lookup("y")
  â””â”€> BÃºsqueda en symbolTableIf: no encontrado
  â””â”€> BÃºsqueda en parent (symbolTableGlobal): âœ“ Encontrado
  â””â”€> Retorna: Type.INT

PASO 7: Verificar operaciÃ³n: INT + INT
  â””â”€> Ambos numÃ©ricos âœ“
  â””â”€> Type.widen(INT, INT) â†’ INT
  â””â”€> Retorna: Type.INT

PASO 8: Verificar compatibilidad: int = int
  â””â”€> âœ“ OK

PASO 9: Insertar 'z' en tabla del bloque if
  â””â”€> Symbol("z", Type.INT, Scope.LOCAL, lÃ­nea=4)
  â””â”€> symbolTableIf.insert(symbol)
  â””â”€> âœ“ Insertado

ESTADO DESPUÃ‰S DE LÃNEA 4:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Tabla de SÃ­mbolos (Global):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nombre â”‚ Tipo â”‚ Scope  â”‚ Valor â”‚ LÃ­nea â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x      â”‚ int  â”‚ global â”‚ 5     â”‚ 1     â”‚
â”‚ y      â”‚ int  â”‚ global â”‚ 10    â”‚ 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
      â†‘
      parent
      â†“
Tabla de SÃ­mbolos (Bloque IF):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nombre â”‚ Tipo â”‚ Scope â”‚ Valor â”‚ LÃ­nea â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ z      â”‚ int  â”‚ local â”‚ 15    â”‚ 4     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

AST Anotado:
  VariableDeclarationNode("z") [type=int âœ“]
    â””â”€ BinaryOpNode(+) [type=int âœ“]
        â”œâ”€ IdentifierNode("x") [type=int âœ“, resolvedTo=Symbol(x) en global]
        â””â”€ IdentifierNode("y") [type=int âœ“, resolvedTo=Symbol(y) en global]

Errores: []
```

#### **LÃ­nea 5: `x = z;` (asignaciÃ³n dentro del if)**

```
INICIO ANÃLISIS LÃNEA 5
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Contexto: TodavÃ­a dentro del bloque if
Scope actual: BLOQUE IF

Nodo: AssignmentNode(name="x", value=IdentifierNode("z"))

PASO 1: Visitar AssignmentNode
  â””â”€> semanticAnalyzer.visitAssignmentNode(node)

PASO 2: Buscar variable 'x'
  â””â”€> symbolTable.lookup("x")
  â””â”€> BÃºsqueda en symbolTableIf: no encontrado
  â””â”€> BÃºsqueda en parent (symbolTableGlobal): âœ“ Encontrado
  â””â”€> symbol = Symbol("x", Type.INT)

PASO 3: Verificar tipo de la expresiÃ³n (z)
  â””â”€> identifierNode("z").accept(this)
  â””â”€> symbolTable.lookup("z")
  â””â”€> BÃºsqueda en symbolTableIf: âœ“ Encontrado
  â””â”€> Retorna: Type.INT

PASO 4: Verificar compatibilidad de tipos
  â””â”€> variable 'x': Type.INT
  â””â”€> expresiÃ³n 'z': Type.INT
  â””â”€> INT.isCompatible(INT) â†’ true âœ“

PASO 5: AsignaciÃ³n vÃ¡lida
  â””â”€> âœ“ OK

ESTADO DESPUÃ‰S DE LÃNEA 5:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

AST Anotado:
  AssignmentNode("x") [type=int âœ“]
    â””â”€ IdentifierNode("z") [type=int âœ“, resolvedTo=Symbol(z) en bloque if]

Errores: []
```

#### **LÃ­nea 6: `}` (salir del bloque if)**

```
SALIR DEL BLOQUE IF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PASO 1: Detectar fin de bloque
  â””â”€> Encontrar cierre }

PASO 2: Restaurar scope anterior
  â””â”€> symbolTable = symbolTable.parent
  â””â”€> Ahora: symbolTable = symbolTableGlobal

PASO 3: Destruir tabla del bloque if
  â””â”€> symbolTableIf se elimina
  â””â”€> Variable 'z' YA NO EXISTE

ESTADO DESPUÃ‰S DE SALIR DEL BLOQUE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Tabla de SÃ­mbolos (Global):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nombre â”‚ Tipo â”‚ Scope  â”‚ Valor â”‚ LÃ­nea â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x      â”‚ int  â”‚ global â”‚ 5     â”‚ 1     â”‚
â”‚ y      â”‚ int  â”‚ global â”‚ 10    â”‚ 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

Nota: 'z' ya no existe (estaba en el bloque if que ya cerrÃ³)
```

#### **LÃ­nea 7: `y = x + 1;` (fuera del if)**

```
INICIO ANÃLISIS LÃNEA 7
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Contexto: Scope global (ya salimos del if)
Scope actual: GLOBAL

Nodo: AssignmentNode(name="y", value=BinaryOpNode(+, x, 1))

PASO 1: Visitar AssignmentNode
  â””â”€> semanticAnalyzer.visitAssignmentNode(node)

PASO 2: Buscar variable 'y'
  â””â”€> symbolTable.lookup("y")
  â””â”€> BÃºsqueda en symbolTableGlobal: âœ“ Encontrado
  â””â”€> symbol = Symbol("y", Type.INT)

PASO 3: Verificar tipo de la expresiÃ³n (x + 1)
  â””â”€> binaryOpNode(+).accept(this)

PASO 4: Verificar operando izquierdo (x)
  â””â”€> identifierNode("x").accept(this)
  â””â”€> symbolTable.lookup("x")
  â””â”€> âœ“ Encontrado en global
  â””â”€> Retorna: Type.INT

PASO 5: Verificar operando derecho (1)
  â””â”€> numberNode(1).accept(this)
  â””â”€> Retorna: Type.INT

PASO 6: Verificar operaciÃ³n: INT + INT
  â””â”€> Ambos numÃ©ricos âœ“
  â””â”€> Type.widen(INT, INT) â†’ INT
  â””â”€> Retorna: Type.INT

PASO 7: Verificar compatibilidad de tipos
  â””â”€> variable 'y': Type.INT
  â””â”€> expresiÃ³n 'x + 1': Type.INT
  â””â”€> INT.isCompatible(INT) â†’ true âœ“

PASO 8: AsignaciÃ³n vÃ¡lida
  â””â”€> âœ“ OK

ESTADO FINAL:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

AST Anotado:
  AssignmentNode("y") [type=int âœ“]
    â””â”€ BinaryOpNode(+) [type=int âœ“]
        â”œâ”€ IdentifierNode("x") [type=int âœ“, resolvedTo=Symbol(x)]
        â””â”€ NumberNode(1) [type=int âœ“]

Errores: []
```

### **Resumen final del anÃ¡lisis:**

```
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ANÃLISIS SEMÃNTICO COMPLETADO
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

INPUT:
  int x = 5;
  int y = 10;
  if (x < y) {
      int z = x + y;
      x = z;
  }
  y = x + 1;

OUTPUT:
  âœ“ AnÃ¡lisis exitoso
  âœ“ 0 errores semÃ¡nticos
  âœ“ Tabla de sÃ­mbolos construida
  âœ“ AST completamente anotado con tipos

TABLA DE SÃMBOLOS FINAL (Global):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Nombre â”‚ Tipo â”‚ Scope  â”‚ Valor â”‚ LÃ­nea â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x      â”‚ int  â”‚ global â”‚ 5     â”‚ 1     â”‚
â”‚ y      â”‚ int  â”‚ global â”‚ 10    â”‚ 2     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

AST ANOTADO:
  ProgramNode [âœ“]
  â”œâ”€â”€ VariableDeclarationNode("x") [type=int âœ“]
  â”‚   â””â”€ NumberNode(5) [type=int âœ“]
  â”œâ”€â”€ VariableDeclarationNode("y") [type=int âœ“]
  â”‚   â””â”€ NumberNode(10) [type=int âœ“]
  â”œâ”€â”€ IfStatementNode [âœ“]
  â”‚   â”œâ”€ condition: BinaryOpNode(<) [type=boolean âœ“]
  â”‚   â”‚   â”œâ”€ IdentifierNode("x") [type=int âœ“]
  â”‚   â”‚   â””â”€ IdentifierNode("y") [type=int âœ“]
  â”‚   â””â”€ then: BlockNode [âœ“]
  â”‚       â”œâ”€ VariableDeclarationNode("z") [type=int âœ“]
  â”‚       â”‚   â””â”€ BinaryOpNode(+) [type=int âœ“]
  â”‚       â”‚       â”œâ”€ IdentifierNode("x") [type=int âœ“]
  â”‚       â”‚       â””â”€ IdentifierNode("y") [type=int âœ“]
  â”‚       â””â”€ AssignmentNode("x") [type=int âœ“]
  â”‚           â””â”€ IdentifierNode("z") [type=int âœ“]
  â””â”€â”€ AssignmentNode("y") [type=int âœ“]
      â””â”€ BinaryOpNode(+) [type=int âœ“]
          â”œâ”€ IdentifierNode("x") [type=int âœ“]
          â””â”€ NumberNode(1) [type=int âœ“]

ESTADÃSTICAS:
  - Declaraciones analizadas: 3 (x, y, z)
  - Asignaciones analizadas: 2
  - Expresiones analizadas: 5
  - Scopes creados: 2 (global + if-block)
  - Tiempo: < 1ms

El programa estÃ¡ SEMÃNTICAMENTE CORRECTO âœ“
Listo para la fase de generaciÃ³n de cÃ³digo.
```

### **Pregunta de comprensiÃ³n:**

Â¿QuÃ© pasarÃ­a si en la lÃ­nea 7 intentamos usar 'z'?

```java
y = z + 1;  // Â¿Error?
```

**Respuesta:**

```
âœ— ERROR SEMÃNTICO

RazÃ³n: La variable 'z' fue declarada dentro del bloque if (lÃ­neas 3-6).
Al salir del bloque if, el scope se destruye y 'z' deja de existir.

Error en lÃ­nea 7:
  Variable 'z' no declarada
  y = z + 1;
      ^

'z' solo existe dentro del bloque if donde fue declarada.
```

---


## PÃ¡gina 16: Manejo de Funciones - DeclaraciÃ³n y Llamadas

### **DeclaraciÃ³n de funciones:**

```java
int suma(int a, int b) {
    return a + b;
}
```

**AST:**
```
FunctionDeclarationNode
â”œâ”€â”€ returnType: int
â”œâ”€â”€ name: "suma"
â”œâ”€â”€ parameters: [
â”‚   Parameter(type=int, name="a"),
â”‚   Parameter(type=int, name="b")
â”‚ ]
â””â”€â”€ body: BlockNode
    â””â”€â”€ ReturnNode
        â””â”€â”€ BinaryOpNode(+, a, b)
```

### **ImplementaciÃ³n del visitFunctionDeclarationNode:**

```java
@Override
public Type visitFunctionDeclarationNode(FunctionDeclarationNode node) {
    // PASO 1: Verificar que no existe funciÃ³n con ese nombre
    if (symbolTable.existsInCurrentScope(node.name)) {
        errors.add(new SemanticException(
            "FunciÃ³n '" + node.name + "' ya declarada", node
        ));
        return null;
    }

    // PASO 2: Crear tipo de funciÃ³n
    List<Type> paramTypes = new ArrayList<>();
    for (Parameter param : node.parameters) {
        paramTypes.add(param.type);
    }
    FunctionType funcType = new FunctionType(node.returnType, paramTypes);

    // PASO 3: Insertar funciÃ³n en tabla GLOBAL
    Symbol funcSymbol = new Symbol(
        node.name,
        funcType,
        Scope.GLOBAL,
        node.lineNumber
    );
    symbolTable.insert(funcSymbol);

    // PASO 4: Crear nuevo scope para el cuerpo de la funciÃ³n
    SymbolTable functionScope = new SymbolTable(symbolTable);
    SymbolTable previousScope = symbolTable;
    symbolTable = functionScope;

    // PASO 5: Insertar parÃ¡metros en el scope de la funciÃ³n
    for (Parameter param : node.parameters) {
        Symbol paramSymbol = new Symbol(
            param.name,
            param.type,
            Scope.LOCAL,
            node.lineNumber
        );
        functionScope.insert(paramSymbol);
    }

    // PASO 6: Guardar tipo de retorno esperado (para verificar returns)
    Type previousReturnType = currentReturnType;
    currentReturnType = node.returnType;

    // PASO 7: Verificar cuerpo de la funciÃ³n
    node.body.accept(this);

    // PASO 8: Restaurar scope anterior y tipo de retorno
    symbolTable = previousScope;
    currentReturnType = previousReturnType;

    return funcType;
}
```

**Traza completa:**

```
DeclaraciÃ³n: int suma(int a, int b) { return a + b; }

PASO 1: Verificar nombre Ãºnico
  â””â”€> symbolTable.existsInCurrentScope("suma") â†’ false âœ“

PASO 2: Crear tipo de funciÃ³n
  â””â”€> paramTypes = [Type.INT, Type.INT]
  â””â”€> funcType = FunctionType(Type.INT, [Type.INT, Type.INT])
  â””â”€> Signatura: "(int, int) -> int"

PASO 3: Insertar en tabla global
  Tabla Global:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Nombre â”‚ Tipo                 â”‚ Scope  â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ suma   â”‚ (int, int) -> int   â”‚ global â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PASO 4: Crear scope de funciÃ³n
  â””â”€> functionScope = new SymbolTable(globalScope)

PASO 5: Insertar parÃ¡metros
  Tabla de FunciÃ³n 'suma':
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Nombre â”‚ Tipo â”‚ Scope â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ a      â”‚ int  â”‚ local â”‚
  â”‚ b      â”‚ int  â”‚ local â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

PASO 6: Guardar tipo de retorno esperado
  â””â”€> currentReturnType = Type.INT

PASO 7: Analizar cuerpo { return a + b; }
  â””â”€> visitReturnNode(ReturnNode)
      â””â”€> Verificar expresiÃ³n: a + b
          â””â”€> lookup("a") â†’ Symbol(a, int) âœ“
          â””â”€> lookup("b") â†’ Symbol(b, int) âœ“
          â””â”€> Tipo de (a + b) = int
      â””â”€> Verificar compatibilidad: int = int âœ“

PASO 8: Restaurar scope
  â””â”€> symbolTable = globalScope
  â””â”€> currentReturnType = null

RESULTADO: âœ“ FunciÃ³n declarada correctamente
```

### **Llamadas a funciones:**

```java
int resultado = suma(5, 10);
```

### **ImplementaciÃ³n del visitFunctionCallNode:**

```java
@Override
public Type visitFunctionCallNode(FunctionCallNode node) {
    // PASO 1: Buscar la funciÃ³n
    Symbol funcSymbol = symbolTable.lookup(node.functionName);
    if (funcSymbol == null) {
        errors.add(new SemanticException(
            "FunciÃ³n '" + node.functionName + "' no declarada", node
        ));
        return Type.ERROR;
    }

    // PASO 2: Verificar que es una funciÃ³n
    if (!(funcSymbol.type instanceof FunctionType)) {
        errors.add(new SemanticException(
            "'" + node.functionName + "' no es una funciÃ³n", node
        ));
        return Type.ERROR;
    }

    FunctionType funcType = (FunctionType) funcSymbol.type;

    // PASO 3: Verificar nÃºmero de argumentos
    if (node.arguments.size() != funcType.parameterTypes.size()) {
        errors.add(new SemanticException(
            "FunciÃ³n '" + node.functionName + "' espera " +
            funcType.parameterTypes.size() + " argumentos, se recibieron " +
            node.arguments.size(), node
        ));
        return funcType.returnType;
    }

    // PASO 4: Verificar tipo de cada argumento
    for (int i = 0; i < node.arguments.size(); i++) {
        Type argType = node.arguments.get(i).accept(this);
        Type paramType = funcType.parameterTypes.get(i);

        if (!argType.isCompatible(paramType)) {
            errors.add(new SemanticException(
                "Argumento " + (i+1) + ": se esperaba " + paramType +
                ", se obtuvo " + argType, node
            ));
        }
    }

    // PASO 5: Retornar tipo de retorno de la funciÃ³n
    node.type = funcType.returnType;
    return funcType.returnType;
}
```

**Ejemplo con error:**

```java
int suma(int a, int b) { return a + b; }
int x = suma(5, "hola");  // âœ— Error en argumento 2
```

**Traza:**

```
Llamada: suma(5, "hola")

PASO 1: Buscar funciÃ³n
  â””â”€> lookup("suma") â†’ Symbol(suma, (int, int) -> int) âœ“

PASO 2: Verificar que es funciÃ³n
  â””â”€> funcSymbol.type instanceof FunctionType â†’ true âœ“

PASO 3: Verificar cantidad de argumentos
  â””â”€> Esperados: 2
  â””â”€> Recibidos: 2
  â””â”€> 2 == 2 âœ“

PASO 4: Verificar tipo de argumentos
  Argumento 1:
    â””â”€> checkExpression(NumberNode(5))
    â””â”€> Retorna: Type.INT
    â””â”€> Esperado: Type.INT
    â””â”€> INT.isCompatible(INT) â†’ true âœ“

  Argumento 2:
    â””â”€> checkExpression(StringNode("hola"))
    â””â”€> Retorna: Type.STRING
    â””â”€> Esperado: Type.INT
    â””â”€> STRING.isCompatible(INT) â†’ false âœ—

  LANZAR EXCEPCIÃ“N:
    "Argumento 2: se esperaba int, se obtuvo String"

RESULTADO: âœ— ERROR SEMÃNTICO
```

---

## PÃ¡gina 17: Manejo de Loops y Control de Flujo

### **While loops:**

```java
while (condicion) {
    // cuerpo
    break;
}
```

### **ImplementaciÃ³n:**

```java
@Override
public Type visitWhileStatementNode(WhileStatementNode node) {
    // PASO 1: Verificar que la condiciÃ³n es booleana
    Type condType = node.condition.accept(this);
    if (!condType.isBoolean()) {
        errors.add(new SemanticException(
            "CondiciÃ³n de while debe ser boolean, se obtuvo " + condType, node
        ));
    }

    // PASO 2: Marcar que estamos dentro de un loop
    boolean wasInLoop = inLoop;
    inLoop = true;

    // PASO 3: Verificar el cuerpo
    node.body.accept(this);

    // PASO 4: Restaurar estado
    inLoop = wasInLoop;

    return null;
}
```

### **Break y Continue:**

```java
@Override
public Type visitBreakNode(BreakNode node) {
    if (!inLoop) {
        errors.add(new SemanticException(
            "break debe estar dentro de un loop", node
        ));
    }
    return null;
}

@Override
public Type visitContinueNode(ContinueNode node) {
    if (!inLoop) {
        errors.add(new SemanticException(
            "continue debe estar dentro de un loop", node
        ));
    }
    return null;
}
```

### **Ejemplo completo:**

```java
int i = 0;
while (i < 10) {
    if (i == 5) {
        break;
    }
    i = i + 1;
}
```

**AnÃ¡lisis:**

```
1. Declarar i = 0
   â””â”€> âœ“ OK

2. While (i < 10)
   â””â”€> CondiciÃ³n: i < 10
       â””â”€> Tipo de i: int
       â””â”€> Tipo de 10: int
       â””â”€> OperaciÃ³n: int < int â†’ boolean âœ“
   â””â”€> inLoop = true

3. If (i == 5)
   â””â”€> CondiciÃ³n: i == 5
       â””â”€> Tipo: boolean âœ“

4. Break
   â””â”€> Verificar: inLoop â†’ true âœ“
   â””â”€> OK

5. i = i + 1
   â””â”€> Tipo de i: int
   â””â”€> Tipo de (i + 1): int
   â””â”€> âœ“ OK

6. Salir del while
   â””â”€> inLoop = false

RESULTADO: âœ“ Programa correcto
```

---

## PÃ¡gina 18: Testing del Analizador SemÃ¡ntico

### **Estructura de tests:**

```java
class SemanticAnalyzerTest {
    private SemanticAnalyzer analyzer;
    private Parser parser;

    @BeforeEach
    void setUp() {
        analyzer = new SemanticAnalyzer();
        parser = new Parser();
    }

    // â”â”â” TESTS DE CASOS VÃLIDOS â”â”â”

    @Test
    void testValidDeclaration() {
        String code = "int x = 5;";
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        // Verificar sin errores
        assertTrue(analyzer.getErrors().isEmpty());
        
        // Verificar tabla de sÃ­mbolos
        Symbol symbol = analyzer.getSymbolTable().lookup("x");
        assertNotNull(symbol);
        assertEquals(Type.INT, symbol.type);
    }

    @Test
    void testValidFunctionDeclaration() {
        String code = """
            int suma(int a, int b) {
                return a + b;
            }
        """;
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertTrue(analyzer.getErrors().isEmpty());
        Symbol suma = analyzer.getSymbolTable().lookup("suma");
        assertNotNull(suma);
        assertTrue(suma.type instanceof FunctionType);
    }

    // â”â”â” TESTS DE ERRORES â”â”â”

    @Test
    void testUndeclaredVariable() {
        String code = "x = 5;"; // x no declarada
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertEquals(1, analyzer.getErrors().size());
        SemanticException error = analyzer.getErrors().get(0);
        assertTrue(error.getMessage().contains("no declarada"));
    }

    @Test
    void testDuplicateDeclaration() {
        String code = """
            int x = 5;
            int x = 10;
        """;
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertEquals(1, analyzer.getErrors().size());
        assertTrue(analyzer.getErrors().get(0).getMessage().contains("ya declarada"));
    }

    @Test
    void testTypeIncompatibility() {
        String code = """
            int x = 5;
            x = "hello";
        """;
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertEquals(1, analyzer.getErrors().size());
        SemanticException error = analyzer.getErrors().get(0);
        assertTrue(error.getMessage().contains("tipos"));
        assertEquals(2, error.lineNumber);
    }

    @Test
    void testFunctionCallWrongArgCount() {
        String code = """
            int suma(int a, int b) {
                return a + b;
            }
            int x = suma(5);
        """;
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertEquals(1, analyzer.getErrors().size());
        assertTrue(analyzer.getErrors().get(0).getMessage().contains("argumentos"));
    }

    @Test
    void testBreakOutsideLoop() {
        String code = """
            if (true) {
                break;
            }
        """;
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertEquals(1, analyzer.getErrors().size());
        assertTrue(analyzer.getErrors().get(0).getMessage().contains("loop"));
    }

    // â”â”â” TESTS DE SCOPING â”â”â”

    @Test
    void testScopingRules() {
        String code = """
            int x = 10;
            {
                int x = 20; // shadowing vÃ¡lido
                int y = x;  // debe usar x = 20
            }
            int z = y; // ERROR: y no existe aquÃ­
        """;
        ProgramNode ast = parser.parse(code);

        analyzer.analyze(ast);

        assertEquals(1, analyzer.getErrors().size());
        assertTrue(analyzer.getErrors().get(0).getMessage().contains("y"));
    }

    // â”â”â” TEST COMPLETO â”â”â”

    @Test
    void testCompleteProgram() {
        String code = """
            int factorial(int n) {
                if (n <= 1) {
                    return 1;
                }
                return n * factorial(n - 1);
            }

            int main() {
                int result = factorial(5);
                return result;
            }
        """;

        ProgramNode ast = parser.parse(code);
        analyzer.analyze(ast);

        assertTrue(analyzer.getErrors().isEmpty());
        assertNotNull(analyzer.getSymbolTable().lookup("factorial"));
        assertNotNull(analyzer.getSymbolTable().lookup("main"));
    }
}
```

---

## PÃ¡gina 19: IntegraciÃ³n con el Compilador Completo

### **Pipeline del compilador:**

```java
public class Compiler {
    private Lexer lexer;
    private Parser parser;
    private SemanticAnalyzer semanticAnalyzer;
    private CodeGenerator codeGenerator;

    public CompilationResult compile(String sourceCode) {
        CompilationResult result = new CompilationResult();

        try {
            // â”â”â” FASE 1: AnÃ¡lisis LÃ©xico â”â”â”
            System.out.println("=== FASE 1: AnÃ¡lisis LÃ©xico ===");
            List<Token> tokens = lexer.tokenize(sourceCode);
            result.tokens = tokens;
            System.out.println("âœ“ " + tokens.size() + " tokens generados");

            // â”â”â” FASE 2: AnÃ¡lisis SintÃ¡ctico â”â”â”
            System.out.println("\n=== FASE 2: AnÃ¡lisis SintÃ¡ctico ===");
            ProgramNode ast = parser.parse(tokens);
            result.ast = ast;
            System.out.println("âœ“ AST construido exitosamente");

            // â”â”â” FASE 3: AnÃ¡lisis SemÃ¡ntico â”â”â”
            System.out.println("\n=== FASE 3: AnÃ¡lisis SemÃ¡ntico ===");
            semanticAnalyzer.analyze(ast);

            if (!semanticAnalyzer.getErrors().isEmpty()) {
                System.out.println("âœ— Errores semÃ¡nticos encontrados:");
                for (SemanticException error : semanticAnalyzer.getErrors()) {
                    System.out.println("  " + error);
                }
                result.errors = semanticAnalyzer.getErrors();
                result.success = false;
                return result;
            }

            result.symbolTable = semanticAnalyzer.getSymbolTable();
            System.out.println("âœ“ VerificaciÃ³n semÃ¡ntica completada");

            // â”â”â” FASE 4: GeneraciÃ³n de CÃ³digo â”â”â”
            System.out.println("\n=== FASE 4: GeneraciÃ³n de CÃ³digo ===");
            String code = codeGenerator.generate(ast, result.symbolTable);
            result.generatedCode = code;
            System.out.println("âœ“ CÃ³digo generado exitosamente");

            result.success = true;

        } catch (LexicalException e) {
            System.err.println("âŒ Error lÃ©xico: " + e.getMessage());
            result.success = false;
        } catch (ParseException e) {
            System.err.println("âŒ Error sintÃ¡ctico: " + e.getMessage());
            result.success = false;
        } catch (Exception e) {
            System.err.println("âŒ Error inesperado: " + e.getMessage());
            result.success = false;
        }

        return result;
    }
}

class CompilationResult {
    boolean success;
    List<Token> tokens;
    ProgramNode ast;
    SymbolTable symbolTable;
    List<SemanticException> errors;
    String generatedCode;
}
```

### **Ejemplo de uso:**

```java
public class Main {
    public static void main(String[] args) {
        String sourceCode = """
            int x = 5;
            int y = 10;
            int suma = x + y;

            if (suma > 10) {
                suma = suma * 2;
            }
        """;

        Compiler compiler = new Compiler();
        CompilationResult result = compiler.compile(sourceCode);

        if (result.success) {
            System.out.println("\nâœ“ CompilaciÃ³n exitosa!");
            System.out.println("\nCÃ³digo generado:");
            System.out.println(result.generatedCode);
        } else {
            System.out.println("\nâœ— CompilaciÃ³n fallida");
        }
    }
}
```

**Salida:**

```
=== FASE 1: AnÃ¡lisis LÃ©xico ===
âœ“ 27 tokens generados

=== FASE 2: AnÃ¡lisis SintÃ¡ctico ===
âœ“ AST construido exitosamente

=== FASE 3: AnÃ¡lisis SemÃ¡ntico ===
âœ“ VerificaciÃ³n semÃ¡ntica completada

=== FASE 4: GeneraciÃ³n de CÃ³digo ===
âœ“ CÃ³digo generado exitosamente

âœ“ CompilaciÃ³n exitosa!

CÃ³digo generado:
    MOV R1, 5
    MOV R2, 10
    ADD R3, R1, R2
    CMP R3, 10
    JLE L1
    MUL R3, R3, 2
L1: ...
```

---

## PÃ¡gina 20: Herramientas de Debugging - VisualizaciÃ³n

### **Visualizador de Tabla de SÃ­mbolos:**

```java
class SymbolTablePrinter {
    public void print(SymbolTable table) {
        System.out.println("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        System.out.println("     TABLA DE SÃMBOLOS");
        System.out.println("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        print(table, 0);
    }

    private void print(SymbolTable table, int depth) {
        String indent = "  ".repeat(depth);

        System.out.println(indent + "â”Œâ”€ Scope nivel " + depth);
        System.out.println(indent + "â”‚");

        for (Symbol symbol : table.getSymbols()) {
            System.out.printf(indent + "â”‚  %-15s : %-10s (lÃ­nea %d)%n",
                symbol.name,
                symbol.type.name,
                symbol.lineNumber
            );
        }

        // Scopes hijos
        for (SymbolTable child : table.getChildren()) {
            print(child, depth + 1);
        }

        System.out.println(indent + "â””â”€");
    }
}
```

**Salida:**

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     TABLA DE SÃMBOLOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”Œâ”€ Scope nivel 0 (Global)
â”‚
â”‚  x               : int        (lÃ­nea 1)
â”‚  y               : int        (lÃ­nea 2)
â”‚  suma            : (int,int)->int  (lÃ­nea 4)
â”‚
  â”Œâ”€ Scope nivel 1 (FunciÃ³n suma)
  â”‚
  â”‚  a             : int        (lÃ­nea 4)
  â”‚  b             : int        (lÃ­nea 4)
  â””â”€
â””â”€
```

### **Visualizador de AST Anotado:**

```java
class AnnotatedASTPrinter implements ASTVisitor<Void> {
    private int indent = 0;

    public void print(ASTNode node) {
        node.accept(this);
    }

    @Override
    public Void visitProgramNode(ProgramNode node) {
        println("ProgramNode");
        indent++;
        for (StatementNode stmt : node.statements) {
            stmt.accept(this);
        }
        indent--;
        return null;
    }

    @Override
    public Void visitDeclarationNode(DeclarationNode node) {
        println("DeclarationNode: " + node.name + " [type=" + node.type + "]");
        if (node.initializer != null) {
            indent++;
            node.initializer.accept(this);
            indent--;
        }
        return null;
    }

    @Override
    public Void visitBinaryOpNode(BinaryOpNode node) {
        println("BinaryOp: " + node.operator + " [type=" + node.type + "]");
        indent++;
        node.left.accept(this);
        node.right.accept(this);
        indent--;
        return null;
    }

    @Override
    public Void visitIdentifierNode(IdentifierNode node) {
        println("Identifier: " + node.name +
               " [type=" + node.type +
               ", resolvedTo=" + node.resolvedSymbol.name + "]");
        return null;
    }

    private void println(String text) {
        System.out.println("  ".repeat(indent) + text);
    }
}
```

**Salida:**

```
ProgramNode
  DeclarationNode: x [type=int]
    NumberNode: 5 [type=int]
  DeclarationNode: y [type=int]
    BinaryOp: + [type=int]
      Identifier: x [type=int, resolvedTo=x]
      NumberNode: 10 [type=int]
```

---

## PÃ¡gina 21: Optimizaciones SemÃ¡nticas

### **Constant Folding:**

```java
class ConstantFoldingOptimizer implements ASTVisitor<ExpressionNode> {
    @Override
    public ExpressionNode visitBinaryOpNode(BinaryOpNode node) {
        // Optimizar operandos primero
        ExpressionNode left = node.left.accept(this);
        ExpressionNode right = node.right.accept(this);

        // Si ambos son constantes, evaluar en compilaciÃ³n
        if (left instanceof NumberNode && right instanceof NumberNode) {
            NumberNode leftNum = (NumberNode) left;
            NumberNode rightNum = (NumberNode) right;

            double result = switch (node.operator) {
                case PLUS -> leftNum.value + rightNum.value;
                case MINUS -> leftNum.value - rightNum.value;
                case MULTIPLY -> leftNum.value * rightNum.value;
                case DIVIDE -> leftNum.value / rightNum.value;
                default -> throw new IllegalStateException();
            };

            return new NumberNode(result);
        }

        return new BinaryOpNode(left, node.operator, right);
    }
}
```

**Ejemplo:**

```
Antes:  x = 2 + 3 * 4;
DespuÃ©s: x = 2 + 12;  â†’ x = 14;
```

### **Dead Code Elimination:**

```java
class DeadCodeEliminator implements ASTVisitor<StatementNode> {
    @Override
    public StatementNode visitIfStatementNode(IfStatementNode node) {
        if (node.condition instanceof BooleanNode) {
            BooleanNode cond = (BooleanNode) node.condition;

            if (cond.value) {
                return node.thenBranch;  // Solo mantener then
            } else {
                return node.elseBranch;  // Solo mantener else
            }
        }
        return node;
    }
}
```

**Ejemplo:**

```
Antes:  if (true) { x = 5; } else { y = 10; }
DespuÃ©s: x = 5;
```

---

## PÃ¡gina 22: Resumen y Conclusiones

### **ğŸ¯ Lo que hemos aprendido:**

1. **Arquitectura del Analizador SemÃ¡ntico**
   - Componentes: SymbolTable, TypeChecker, ErrorHandler
   - PatrÃ³n Visitor para recorrer el AST
   - SeparaciÃ³n de responsabilidades

2. **Tabla de SÃ­mbolos**
   - Estructura de datos fundamental
   - GestiÃ³n de scopes anidados
   - Operaciones: insert, lookup, existsInCurrentScope

3. **Scopes y Shadowing**
   - Reglas de visibilidad
   - BÃºsqueda recursiva en scopes padre
   - Shadowing vÃ¡lido vs redeclaraciÃ³n invÃ¡lida

4. **Sistema de Tipos**
   - JerarquÃ­a de tipos (primitivos, arrays, funciones)
   - VerificaciÃ³n de compatibilidad
   - PromociÃ³n implÃ­cita vs cast explÃ­cito

5. **Errores SemÃ¡nticos**
   - CatÃ¡logo completo de errores
   - Mensajes descriptivos con lÃ­nea y columna
   - Manejo de mÃºltiples errores

6. **PatrÃ³n Visitor**
   - DiseÃ±o elegante para operaciones sobre AST
   - FÃ¡cil agregar nuevas operaciones
   - ReutilizaciÃ³n del AST

### **ğŸ’¡ Conceptos clave:**

```
âœ“ Sintaxis correcta â‰  SemÃ¡ntica correcta
  - El anÃ¡lisis sintÃ¡ctico verifica la FORMA
  - El anÃ¡lisis semÃ¡ntico verifica el SIGNIFICADO

âœ“ La tabla de sÃ­mbolos es el "cerebro" del compilador
  - Almacena TODO sobre identificadores
  - Permite verificar tipos y scopes

âœ“ Scopes anidados requieren bÃºsqueda recursiva
  - Buscar desde scope actual hacia scopes padre
  - Variables de scope interno "sombrea" a las externas

âœ“ El patrÃ³n Visitor separa estructura de operaciones
  - AST no cambia
  - Operaciones se agregan como nuevos Visitors
```

### **ğŸš€ Diferencias clave:**

| Aspecto | SintÃ¡ctico | SemÃ¡ntico |
|---------|-----------|-----------|
| **Entrada** | Tokens | AST |
| **Salida** | AST | AST anotado + Tabla |
| **Verifica** | GramÃ¡tica | Tipos, scopes, contexto |
| **Ejemplo Error** | `if x > 0)` | `int x = "hello"` |

### **ğŸ› ï¸ Habilidades desarrolladas:**

- âœ“ Implementar tabla de sÃ­mbolos con HashMap
- âœ“ DiseÃ±ar sistema de tipos robusto
- âœ“ Usar patrÃ³n Visitor eficientemente
- âœ“ Manejar scopes anidados correctamente
- âœ“ Detectar y reportar errores semÃ¡nticos
- âœ“ Integrar anÃ¡lisis en pipeline completo

### **ğŸ“š Para profundizar:**

- "Compilers: Principles, Techniques, and Tools" (Dragon Book)
- "Modern Compiler Implementation in Java" (Tiger Book)
- "Engineering a Compiler" (Cooper & Torczon)
- DocumentaciÃ³n de ANTLR y herramientas similares

### **ğŸ”œ PrÃ³ximos pasos:**

1. **GeneraciÃ³n de CÃ³digo Intermedio**
   - Transformar AST a cÃ³digo de 3 direcciones
   - Optimizaciones de cÃ³digo intermedio

2. **OptimizaciÃ³n**
   - Constant folding
   - Dead code elimination
   - Common subexpression elimination

3. **GeneraciÃ³n de CÃ³digo Final**
   - AsignaciÃ³n de registros
   - SelecciÃ³n de instrucciones
   - CÃ³digo mÃ¡quina o bytecode

**Â¡El anÃ¡lisis semÃ¡ntico es donde el compilador realmente "entiende" tu cÃ³digo!** ğŸ§ âœ¨

---

## PÃ¡gina 23: Ejercicios PrÃ¡cticos y AutoevaluaciÃ³n

### **Ejercicio 1: AnÃ¡lisis BÃ¡sico**

Â¿QuÃ© errores semÃ¡nticos tiene este cÃ³digo?

```java
int x = 5;
int x = 10;
y = x + 5;
int z = x + "hola";
```

**Respuesta:**
```
LÃ­nea 2: Variable 'x' ya declarada en lÃ­nea 1
LÃ­nea 3: Variable 'y' no declarada
LÃ­nea 4: Operador '+' incompatible: int + String
```

### **Ejercicio 2: Scoping**

Â¿QuÃ© imprime este cÃ³digo?

```java
int x = 10;
void foo() {
    int x = 20;
    System.out.println(x);
}
foo();
System.out.println(x);
```

**Respuesta:**
```
20  (x local de foo)
10  (x global)
```

### **Ejercicio 3: Funciones**

Â¿QuÃ© errores hay?

```java
int suma(int a, int b) {
    return a + b;
}
int x = suma(5);
int y = suma(5, 10, 15);
```

**Respuesta:**
```
LÃ­nea 4: suma() espera 2 argumentos, se recibieron 1
LÃ­nea 5: suma() espera 2 argumentos, se recibieron 3
```

### **Ejercicio 4: DiseÃ±o**

Implementa un mÃ©todo `visitArrayAccessNode` que verifique:
1. Que el array existe
2. Que es realmente un array
3. Que el Ã­ndice es int

**SoluciÃ³n:**

```java
@Override
public Type visitArrayAccessNode(ArrayAccessNode node) {
    // 1. Verificar tipo del array
    Type arrayType = node.array.accept(this);

    // 2. Verificar que es un array
    if (!(arrayType instanceof ArrayType)) {
        errors.add(new SemanticException(
            "No se puede indexar tipo " + arrayType, node
        ));
        return Type.ERROR;
    }

    // 3. Verificar que el Ã­ndice es entero
    Type indexType = node.index.accept(this);
    if (!indexType.isInt()) {
        errors.add(new SemanticException(
            "Ãndice debe ser int, se obtuvo " + indexType, node
        ));
    }

    // 4. Retornar tipo de los elementos
    return ((ArrayType) arrayType).elementType;
}
```

### **AutoevaluaciÃ³n:**

```
â–¡ Entiendo la diferencia entre anÃ¡lisis sintÃ¡ctico y semÃ¡ntico
â–¡ Puedo explicar cÃ³mo funciona la tabla de sÃ­mbolos
â–¡ Comprendo las reglas de scoping y shadowing
â–¡ SÃ© cÃ³mo funciona el patrÃ³n Visitor
â–¡ Puedo implementar verificaciÃ³n de tipos
â–¡ Entiendo promociÃ³n implÃ­cita vs cast explÃ­cito
â–¡ Puedo detectar y reportar errores semÃ¡nticos
â–¡ SÃ© integrar el analizador en un compilador completo

Si marcaste todas: Â¡Felicidades! Dominas el anÃ¡lisis semÃ¡ntico âœ“
Si te faltan algunas: Revisa las pÃ¡ginas correspondientes
```

### **Proyecto Final Sugerido:**

Implementa un analizador semÃ¡ntico completo para un lenguaje simple con:
- Variables (int, double, boolean)
- Funciones con parÃ¡metros
- Estructuras de control (if, while)
- Arrays
- Scopes anidados

**Entregables:**
1. CÃ³digo del analizador
2. Suite de tests (mÃ­nimo 20 casos)
3. DocumentaciÃ³n de errores detectados
4. Ejemplos de uso

---

**FIN DE LA PRESENTACIÃ“N**

Â¡Gracias por estudiar el Analizador SemÃ¡ntico!

Para mÃ¡s informaciÃ³n, consulta:
- DocumentaciÃ³n del curso
- Repositorio de ejemplos
- Foros de discusiÃ³n

**Universidad EAM - 2025**
**TeorÃ­a de Lenguajes Formales y Compiladores**

