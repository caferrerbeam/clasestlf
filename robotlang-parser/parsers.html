<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parsers - Construcci√≥n y Funcionamiento | RoboLang Parser</title>
    <meta name="description" content="Aprende c√≥mo se construyen los parsers paso a paso, desde los m√°s simples hasta los m√°s complejos">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/parser-implementation.css">
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <header class="section-header">
        <nav class="section-nav">
            <div class="nav-content">
                <a href="index.html" class="nav-home">üè† Inicio</a>
                <div class="nav-sections">
                    <a href="ast.html" class="nav-item">üèóÔ∏è AST</a>
                    <a href="parsers.html" class="nav-item active">‚öôÔ∏è Parsers</a>
                    <a href="main-parser.html" class="nav-item">üéØ Parser Principal</a>
                    <a href="testing.html" class="nav-item">üß™ Testing</a>
                    <a href="gui.html" class="nav-item">üé® GUI</a>
                    <a href="implementation.html" class="nav-item">üéØ Implementaci√≥n</a>
                </div>
            </div>
        </nav>
        <div class="section-title">
            <h1>‚öôÔ∏è Parsers - Construcci√≥n y Funcionamiento</h1>
            <p class="section-subtitle">Ense√±ar c√≥mo se construyen los parsers paso a paso</p>
        </div>
    </header>

    <main class="section-content">
        <div class="content-container">
            
            <!-- Parsers 101 - Conceptos B√°sicos -->
            <section class="content-section">
                <h2>üìö Parsers 101 - Conceptos B√°sicos</h2>
                <p class="section-intro">
                    Un parser es el componente que transforma una secuencia de tokens en un 
                    √Årbol de Sintaxis Abstracta (AST), validando que la entrada cumpla con las reglas gram√°ticas del lenguaje.
                </p>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h3>üéØ ¬øQu√© hace un Parser?</h3>
                        <p>
                            El parser toma los tokens generados por el lexer y los organiza en una estructura 
                            jer√°rquica que refleja la sintaxis del programa.
                        </p>
                        <div class="parser-flow">
                            <div class="flow-item">Tokens</div>
                            <span>‚Üí</span>
                            <div class="flow-item highlight">Parser</div>
                            <span>‚Üí</span>
                            <div class="flow-item">AST</div>
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>üèóÔ∏è Interface Parser&lt;T&gt; - El Contrato Universal</h3>
                        <p>
                            Todos nuestros parsers implementan una interface com√∫n que garantiza 
                            consistencia y permite composici√≥n entre parsers.
                        </p>
                        <div class="code-example">
<pre><code class="language-java">public interface Parser&lt;T&gt; {
    T parse(ParseContext context) throws ParseException;
}</code></pre>
                        </div>
                        
                        <div class="interface-explanation">
                            <h4>üîç Desglose de la Interface:</h4>
                            <div class="explanation-grid">
                                <div class="explanation-item">
                                    <h5>&lt;T&gt; - Gen√©rico de Tipo</h5>
                                    <p><strong>¬øPor qu√© gen√©rico?</strong> Permite que cada parser retorne su tipo espec√≠fico de nodo AST:</p>
                                    <ul>
                                        <li><code>Parser&lt;NumberNode&gt;</code> ‚Üí retorna NumberNode</li>
                                        <li><code>Parser&lt;IfStatementNode&gt;</code> ‚Üí retorna IfStatementNode</li>
                                        <li><code>Parser&lt;ExpressionNode&gt;</code> ‚Üí retorna cualquier expresi√≥n</li>
                                    </ul>
                                </div>
                                
                                <div class="explanation-item">
                                    <h5>parse(ParseContext context)</h5>
                                    <p><strong>¬øQu√© recibe?</strong> Un contexto que mantiene el estado del parsing:</p>
                                    <ul>
                                        <li><code>context</code>: Posici√≥n actual en los tokens</li>
                                        <li>M√©todos para navegar: <code>getCurrentToken()</code>, <code>advance()</code></li>
                                        <li>M√©todos para consumir: <code>match()</code>, <code>consume()</code></li>
                                    </ul>
                                </div>
                                
                                <div class="explanation-item">
                                    <h5>throws ParseException</h5>
                                    <p><strong>¬øCu√°ndo falla?</strong> Si encuentra sintaxis inv√°lida:</p>
                                    <ul>
                                        <li>Token inesperado: esperaba NUMBER, encontr√≥ IF</li>
                                        <li>Fin prematuro: esperaba ), lleg√≥ EOF</li>
                                        <li>Secuencia inv√°lida: dos n√∫meros seguidos</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div class="interface-benefits">
                            <h4>üéØ Beneficios de esta Interface:</h4>
                            <div class="benefits-list">
                                <div class="benefit">
                                    <strong>1. Uniformidad:</strong> Todos los parsers "se ven" igual desde afuera
                                </div>
                                <div class="benefit">
                                    <strong>2. Composici√≥n:</strong> Un parser puede usar otro parser sin conocer los detalles internos
                                </div>
                                <div class="benefit">
                                    <strong>3. Testing:</strong> F√°cil crear mocks y tests unitarios
                                </div>
                                <div class="benefit">
                                    <strong>4. Polimorfismo:</strong> Tratar diferentes parsers de manera uniforme
                                </div>
                            </div>
                        </div>
                        
                        <div class="interface-examples">
                            <h4>üíª Ejemplos de Implementaci√≥n:</h4>
                            <div class="code-comparison">
                                <div class="code-version">
                                    <h5>Parser Simple:</h5>
<pre><code class="language-java">public class NumberParser implements Parser&lt;NumberNode&gt; {
    @Override
    public NumberNode parse(ParseContext context) 
            throws ParseException {
        // Implementaci√≥n espec√≠fica para n√∫meros
        Token token = context.getCurrentToken();
        if (token.getType() == TokenType.NUMBER) {
            context.advance();
            return new NumberNode(Integer.parseInt(token.getValue()));
        }
        throw new ParseException("Expected number", token);
    }
}</code></pre>
                                </div>
                                
                                <div class="code-version">
                                    <h5>Parser Compuesto:</h5>
<pre><code class="language-java">public class ComparisonParser implements Parser&lt;ComparisonNode&gt; {
    private Parser&lt;ValueNode&gt; valueParser = new ValueParser();
    private Parser&lt;OperatorNode&gt; operatorParser = new OperatorParser();
    
    @Override
    public ComparisonNode parse(ParseContext context) 
            throws ParseException {
        // Usa otros parsers para construir la comparaci√≥n
        ValueNode left = valueParser.parse(context);
        OperatorNode op = operatorParser.parse(context);
        ValueNode right = valueParser.parse(context);
        return new ComparisonNode(left, op, right);
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="interface-pattern">
                            <h4>üé® Patr√≥n de Dise√±o Aplicado:</h4>
                            <p>Esta interface implementa el patr√≥n <strong>Template Method</strong>:</p>
                            <ul>
                                <li><strong>Estructura com√∫n:</strong> Todos reciben ParseContext y retornan AST</li>
                                <li><strong>Implementaci√≥n espec√≠fica:</strong> Cada parser decide c√≥mo procesar su gram√°tica</li>
                                <li><strong>Manejo de errores uniforme:</strong> Todos usan ParseException</li>
                            </ul>
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>üé® Patr√≥n Template Method</h3>
                        <p>
                            Los parsers siguen un patr√≥n com√∫n: verificar token actual, 
                            consumir si coincide, construir nodo AST, y retornar resultado.
                        </p>
                        <div class="pattern-steps">
                            <ol>
                                <li>üîç Examinar token actual</li>
                                <li>‚úÖ Validar tipo esperado</li>
                                <li>üì• Consumir token(s)</li>
                                <li>üå≥ Construir nodo AST</li>
                                <li>‚Ü©Ô∏è Retornar resultado</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ParseContext - El Coraz√≥n del Parser -->
            <section class="content-section">
                <h2>üíì ParseContext - El Coraz√≥n del Parser</h2>
                <p class="section-intro">
                    ParseContext es la clase central que gestiona el estado del parsing. 
                    Mantiene la posici√≥n actual en la lista de tokens y proporciona m√©todos 
                    √∫tiles para navegar y consumir tokens.
                </p>

                <div class="context-methods">
                    <h3>üõ†Ô∏è M√©todos Principales de ParseContext</h3>
                    
                    <div class="method-card">
                        <div class="method-header">
                            <code>Token getCurrentToken()</code>
                            <span class="method-type">Espiar</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Obtiene el token actual <strong>sin consumirlo</strong>. 
                                √ötil para decidir qu√© parser usar o verificar el siguiente elemento.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Ver qu√© viene sin avanzar
Token token = context.getCurrentToken();
if (token.getType() == TokenType.IF) {
    // Es un IF statement
    return ifStatementParser.parse(context);
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>void advance()</code>
                            <span class="method-type">Avanzar</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Avanza al siguiente token en la secuencia. 
                                <strong>Fundamental</strong> despu√©s de procesar un token.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Consumir un n√∫mero
Token token = context.getCurrentToken();
int value = Integer.parseInt(token.getValue());
context.advance(); // ¬°No olvidar avanzar!
return new NumberNode(value);</code></pre>
                            </div>
                            <div class="warning-box">
                                ‚ö†Ô∏è <strong>Error Com√∫n:</strong> Olvidar llamar advance() causa bucles infinitos
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>boolean match(TokenType... types)</code>
                            <span class="method-type">Verificar y Consumir</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica si el token actual es de alguno de los tipos especificados.
                                Si coincide, <strong>consume el token autom√°ticamente</strong> y retorna true.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Manejar m√∫ltiples opciones
if (context.match(TokenType.UP, TokenType.DOWN, 
                   TokenType.LEFT, TokenType.RIGHT)) {
    String direction = previousToken.getValue();
    return new MovementCommandNode(direction);
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>void consume(TokenType type, String message)</code>
                            <span class="method-type">Consumir Obligatorio</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica que el token actual sea del tipo esperado y lo consume.
                                Si no coincide, lanza <strong>ParseException</strong> con el mensaje.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Requerir par√©ntesis
context.consume(TokenType.LPAREN, 
    "Se esperaba '(' despu√©s de IF");
// Si no hay LPAREN, lanza excepci√≥n</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>boolean check(TokenType type)</code>
                            <span class="method-type">Solo Verificar</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica si el token actual es del tipo especificado 
                                <strong>sin consumirlo</strong>. √ötil para lookahead.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Verificar sin consumir
if (context.check(TokenType.ELSE)) {
    // Hay un ELSE, pero no lo consumimos a√∫n
    // Otro parser se encargar√°
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>boolean isAtEnd()</code>
                            <span class="method-type">Detectar Fin</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica si hemos llegado al final de la entrada (EOF).
                                Importante para evitar accesos fuera de l√≠mites.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Parsear lista de statements
List&lt;StatementNode&gt; statements = new ArrayList&lt;&gt;();
while (!context.isAtEnd() && 
       !context.check(TokenType.RBRACE)) {
    statements.add(statementParser.parse(context));
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Parser M√°s Simple - NumberParser -->
            <section class="content-section">
                <h2>üî¢ Parser M√°s Simple - NumberParser</h2>
                <p class="section-intro">
                    Comenzamos con el parser m√°s b√°sico: NumberParser. Este parser reconoce 
                    n√∫meros enteros y los convierte en nodos NumberNode del AST.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>üìù Gram√°tica:</strong> 
                            <code>&lt;number&gt; ::= [0-9]+</code>
                        </div>
                        <div class="bnf-visual">
                            <a href="robotlangbnf.html#number" target="_blank" class="bnf-link">
                                üìñ Ver diagrama visual de number
                            </a>
                        </div>
                    </div>

                    <h3>üíª Implementaci√≥n Completa</h3>
                    <div class="code-walkthrough">
<pre><code class="numbered">public class NumberParser implements Parser&lt;NumberNode&gt; {
    
    @Override
    public NumberNode parse(ParseContext context) 
            throws ParseException {
        
        // 1Ô∏è‚É£ Obtener el token actual
        Token token = context.getCurrentToken();
        
        // 2Ô∏è‚É£ Verificar que sea un NUMBER
        if (token.getType() != TokenType.NUMBER) {
            throw new ParseException(
                "Se esperaba un n√∫mero, pero se encontr√≥: " + 
                token.getType(), token
            );
        }
        
        // 3Ô∏è‚É£ Extraer el valor num√©rico
        int value = Integer.parseInt(token.getValue());
        
        // 4Ô∏è‚É£ IMPORTANTE: Avanzar al siguiente token
        context.advance();
        
        // 5Ô∏è‚É£ Crear y retornar el nodo AST
        return new NumberNode(value);
    }
}</code></pre>
                    </div>

                    <h3>üìã Explicaci√≥n L√≠nea por L√≠nea</h3>
                    <div class="line-explanation">
                        <div class="explanation-item">
                            <span class="line-number">L√≠nea 7:</span>
                            <p>Obtenemos el token actual sin consumirlo. Este es nuestro candidato a n√∫mero.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">L√≠nea 10:</span>
                            <p>Validaci√≥n cr√≠tica: ¬øEs realmente un token NUMBER? Si no, error de sintaxis.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">L√≠nea 17:</span>
                            <p>Convertimos el string del token a entero. Asumimos que el lexer valid√≥ el formato.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">L√≠nea 20:</span>
                            <p><strong>CRUCIAL:</strong> Avanzamos al siguiente token. Sin esto, el parser se atascar√°.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">L√≠nea 23:</span>
                            <p>Creamos el nodo AST con el valor parseado y lo retornamos.</p>
                        </div>
                    </div>

                    <h3>üîç Casos de Prueba</h3>
                    <div class="test-cases">
                        <div class="test-case success">
                            <h4>‚úÖ Caso V√°lido</h4>
<pre><code class="language-java">Entrada: "42"
Tokens: [NUMBER("42"), EOF]
Resultado: NumberNode(value=42)
Token despu√©s: EOF</code></pre>
                        </div>
                        <div class="test-case error">
                            <h4>‚ùå Caso Inv√°lido</h4>
<pre><code class="language-java">Entrada: "UP"
Tokens: [UP, EOF]
Resultado: ParseException
Mensaje: "Se esperaba un n√∫mero, pero se encontr√≥: UP"</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Parser Intermedio - MovementCommandParser -->
            <section class="content-section">
                <h2>üöÄ Parser Intermedio - MovementCommandParser</h2>
                <p class="section-intro">
                    MovementCommandParser maneja m√∫ltiples opciones de comandos de movimiento.
                    Introduce el concepto de parsear una de varias alternativas.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>üìù Gram√°tica:</strong> 
                            <code>&lt;movement_command&gt; ::= "UP" | "DOWN" | "LEFT" | "RIGHT"</code>
                        </div>
                        <div class="bnf-visual">
                            <a href="robotlangbnf.html#movement_command" target="_blank" class="bnf-link">
                                üìñ Ver diagrama visual de movement_command
                            </a>
                        </div>
                    </div>

                    <h3>üíª Implementaci√≥n con match()</h3>
                    <div class="code-comparison">
                        <div class="code-version">
                            <h4>Versi√≥n Elegante con match()</h4>
<pre><code class="language-java">public class MovementCommandParser 
        implements Parser&lt;MovementCommandNode&gt; {
    
    @Override
    public MovementCommandNode parse(ParseContext context) 
            throws ParseException {
        
        // Guardamos el token antes de match()
        Token token = context.getCurrentToken();
        
        // match() verifica Y consume si coincide
        if (context.match(TokenType.UP, TokenType.DOWN,
                          TokenType.LEFT, TokenType.RIGHT)) {
            
            // Usamos el token guardado para obtener direcci√≥n
            String direction = token.getValue();
            return new MovementCommandNode(direction);
        }
        
        // Si llegamos aqu√≠, no era un comando v√°lido
        throw new ParseException(
            "Se esperaba comando de movimiento (UP/DOWN/LEFT/RIGHT)",
            context.getCurrentToken()
        );
    }
}</code></pre>
                        </div>

                        <div class="code-version">
                            <h4>Versi√≥n con switch/case</h4>
<pre><code class="language-java">public class MovementCommandParser 
        implements Parser&lt;MovementCommandNode&gt; {
    
    @Override
    public MovementCommandNode parse(ParseContext context) 
            throws ParseException {
        
        Token token = context.getCurrentToken();
        String direction;
        
        switch (token.getType()) {
            case UP:
                direction = "UP";
                break;
            case DOWN:
                direction = "DOWN";
                break;
            case LEFT:
                direction = "LEFT";
                break;
            case RIGHT:
                direction = "RIGHT";
                break;
            default:
                throw new ParseException(
                    "Se esperaba comando de movimiento",
                    token
                );
        }
        
        context.advance(); // No olvidar avanzar
        return new MovementCommandNode(direction);
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="comparison-note">
                        <h4>üéØ ¬øCu√°ndo usar cada enfoque?</h4>
                        <ul>
                            <li><strong>match():</strong> Cuando todas las opciones se tratan igual</li>
                            <li><strong>switch/case:</strong> Cuando cada opci√≥n requiere l√≥gica diferente</li>
                            <li><strong>if-else:</strong> Para condiciones complejas o anidadas</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Parser Avanzado - IfStatementParser -->
            <section class="content-section">
                <h2>üèóÔ∏è Parser Avanzado - IfStatementParser</h2>
                <p class="section-intro">
                    IfStatementParser es un parser complejo que delega a otros parsers.
                    Demuestra la composici√≥n de parsers y el manejo de estructuras anidadas.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>üìù Gram√°tica:</strong> 
                            <code>&lt;if_stmt&gt; ::= "IF" "(" &lt;condition&gt; ")" &lt;statement_block&gt;</code>
                        </div>
                        <div class="bnf-visual">
                            <a href="robotlangbnf.html#if_statement" target="_blank" class="bnf-link">
                                üìñ Ver diagrama visual de if_statement
                            </a>
                        </div>
                    </div>

                    <h3>üíª Implementaci√≥n con Delegaci√≥n</h3>
<pre><code class="language-java">public class IfStatementParser 
        implements Parser&lt;IfStatementNode&gt; {
    
    // Parsers que necesitamos para delegar
    private final ConditionParser conditionParser;
    private final StatementBlockParser blockParser;
    
    public IfStatementParser() {
        this.conditionParser = new ConditionParser();
        this.blockParser = new StatementBlockParser();
    }
    
    @Override
    public IfStatementNode parse(ParseContext context) 
            throws ParseException {
        
        // 1Ô∏è‚É£ Consumir palabra clave IF
        context.consume(TokenType.IF, 
            "Se esperaba 'IF' al inicio del statement");
        
        // 2Ô∏è‚É£ Consumir par√©ntesis izquierdo
        context.consume(TokenType.LPAREN,
            "Se esperaba '(' despu√©s de IF");
        
        // 3Ô∏è‚É£ DELEGAR: Parsear la condici√≥n
        ConditionNode condition = conditionParser.parse(context);
        
        // 4Ô∏è‚É£ Consumir par√©ntesis derecho
        context.consume(TokenType.RPAREN,
            "Se esperaba ')' despu√©s de la condici√≥n");
        
        // 5Ô∏è‚É£ DELEGAR: Parsear el bloque de statements
        StatementBlockNode thenBlock = blockParser.parse(context);
        
        // 6Ô∏è‚É£ Construir y retornar el nodo IF completo
        return new IfStatementNode(condition, thenBlock);
    }
}</code></pre>

                    <h3>üé® Patr√≥n de Delegaci√≥n</h3>
                    <div class="delegation-diagram">
                        <div class="parser-flow">
                            <div class="parser-box main">
                                <strong>IfStatementParser</strong>
                                <p>Orquesta el proceso</p>
                            </div>
                            <div class="delegation-arrows">
                                <div class="arrow-down">‚Üì Delega</div>
                                <div class="arrow-down">‚Üì Delega</div>
                            </div>
                            <div class="delegated-parsers">
                                <div class="parser-box delegated">
                                    <strong>ConditionParser</strong>
                                    <p>Maneja expresiones booleanas</p>
                                </div>
                                <div class="parser-box delegated">
                                    <strong>StatementBlockParser</strong>
                                    <p>Maneja { statements }</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h3>üîÑ Flujo de Ejecuci√≥n</h3>
                    <div class="execution-flow">
                        <div class="flow-step">
                            <span class="step-num">1</span>
                            <div class="step-content">
                                <strong>Token: IF</strong>
                                <p>consume() verifica y avanza</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">2</span>
                            <div class="step-content">
                                <strong>Token: (</strong>
                                <p>consume() verifica y avanza</p>
                            </div>
                        </div>
                        <div class="flow-step highlight">
                            <span class="step-num">3</span>
                            <div class="step-content">
                                <strong>Tokens: BATTERY > 20</strong>
                                <p>ConditionParser toma el control</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">4</span>
                            <div class="step-content">
                                <strong>Token: )</strong>
                                <p>consume() verifica y avanza</p>
                            </div>
                        </div>
                        <div class="flow-step highlight">
                            <span class="step-num">5</span>
                            <div class="step-content">
                                <strong>Tokens: { UP; }</strong>
                                <p>StatementBlockParser toma el control</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Parser de Dispatching - StatementParser -->
            <section class="content-section">
                <h2>üéØ Parser Dispatcher - StatementParser</h2>
                <p class="section-intro">
                    StatementParser es un parser especial que act√∫a como **dispatcher** (despachador),
                    decidiendo qu√© tipo de statement parsear seg√∫n el token actual.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>üìù Gram√°tica:</strong>
                            <code>&lt;statement&gt; ::= &lt;simple_command&gt; | &lt;repeat_statement&gt; | &lt;if_statement&gt; | &lt;while_statement&gt;</code>
                        </div>
                    </div>

                    <h3>üíª Implementaci√≥n Completa</h3>
<pre><code class="language-java">public class StatementParser implements Parser&lt;StatementNode&gt; {

    private SimpleCommandParser simpleCommandParser;
    private RepeatStatementParser repeatParser;
    private IfStatementParser ifParser;
    private WhileStatementParser whileParser;

    // Inicializaci√≥n perezosa para evitar dependencias circulares
    private void initializeParsers() {
        if (simpleCommandParser == null) {
            simpleCommandParser = new SimpleCommandParser();
            repeatParser = new RepeatStatementParser();
            ifParser = new IfStatementParser();
            whileParser = new WhileStatementParser();
        }
    }

    @Override
    public StatementNode parse(ParseContext context) throws ParseException {
        initializeParsers();
        StatementNode stmt = new StatementNode(context.getCurrentToken());

        // üîç Lookahead: Verificar qu√© tipo de statement viene

        // Comandos simples: UP, DOWN, LEFT, RIGHT, PENUP, PENDOWN
        if (context.check(TokenType.COMMAND_UP, TokenType.COMMAND_DOWN,
                         TokenType.COMMAND_LEFT, TokenType.COMMAND_RIGHT,
                         TokenType.COMMAND_PENUP, TokenType.COMMAND_PENDOWN)) {
            var simpleCmd = simpleCommandParser.parse(context);
            stmt.setStatement(simpleCmd);
            return stmt;
        }

        // REPEAT statement
        if (context.check(TokenType.KEYWORD_REPEAT)) {
            var repeat = repeatParser.parse(context);
            stmt.setStatement(repeat);
            return stmt;
        }

        // IF statement
        if (context.check(TokenType.KEYWORD_IF)) {
            var ifStmt = ifParser.parse(context);
            stmt.setStatement(ifStmt);
            return stmt;
        }

        // WHILE statement
        if (context.check(TokenType.KEYWORD_WHILE)) {
            var whileStmt = whileParser.parse(context);
            stmt.setStatement(whileStmt);
            return stmt;
        }

        throw new ParseException("Se esperaba statement", context.getCurrentToken());
    }
}</code></pre>

                    <h3>üé® Patr√≥n Dispatcher</h3>
                    <div class="pattern-explanation">
                        <h4>¬øPor qu√© usar un dispatcher?</h4>
                        <p>El StatementParser no sabe c√≥mo parsear cada tipo de statement en detalle.
                        En su lugar, <strong>delega</strong> esa responsabilidad a parsers especializados.</p>

                        <div class="dispatcher-benefits">
                            <div class="benefit">
                                <strong>‚úÖ Separaci√≥n de responsabilidades:</strong> Cada parser se encarga de una sola cosa
                            </div>
                            <div class="benefit">
                                <strong>‚úÖ Mantenibilidad:</strong> Cambios en un tipo de statement no afectan otros
                            </div>
                            <div class="benefit">
                                <strong>‚úÖ Extensibilidad:</strong> Agregar nuevos statements es f√°cil
                            </div>
                        </div>
                    </div>

                    <h3>üîç Lookahead Pattern</h3>
                    <p>El patr√≥n clave aqu√≠ es el <strong>lookahead</strong> (mirar adelante sin consumir):</p>
<pre><code class="language-java">// ‚ùå MAL: Consumir antes de verificar
Token token = context.getCurrentToken();
context.advance(); // Ya avanzamos!
if (token.getType() == TokenType.KEYWORD_IF) {
    // Problema: ya consumimos el IF
}

// ‚úÖ BIEN: Verificar antes de delegar
if (context.check(TokenType.KEYWORD_IF)) {
    // El parser de IF se encargar√° de consumir
    var ifStmt = ifParser.parse(context);
}</code></pre>
                </div>
            </section>

            <!-- Parser de Listas - StatementListParser -->
            <section class="content-section">
                <h2>üìú Parser de Listas - StatementListParser</h2>
                <p class="section-intro">
                    StatementListParser maneja secuencias de statements. Es cr√≠tico porque
                    permite que un programa tenga m√∫ltiples instrucciones.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>üìù Gram√°tica:</strong>
                            <code>&lt;statement_list&gt; ::= &lt;statement&gt; | &lt;statement&gt; &lt;statement_list&gt;</code>
                        </div>
                    </div>

                    <h3>üíª Implementaci√≥n Completa</h3>
<pre><code class="language-java">public class StatementListParser implements Parser&lt;StatementListNode&gt; {

    private StatementParser statementParser;

    private void initializeParsers() {
        if (statementParser == null) {
            statementParser = new StatementParser();
        }
    }

    @Override
    public StatementListNode parse(ParseContext context) throws ParseException {
        initializeParsers();
        StatementListNode stmtList = new StatementListNode(context.getCurrentToken());

        // 1Ô∏è‚É£ Parsear AL MENOS un statement
        var firstStmt = statementParser.parse(context);
        stmtList.addStatement(firstStmt);

        // 2Ô∏è‚É£ Parsear statements adicionales mientras haya
        while (!context.isAtEnd() && !context.check(TokenType.RBRACE, TokenType.EOF)) {
            // Verificar si el siguiente token inicia un statement v√°lido
            if (context.check(TokenType.COMMAND_UP, TokenType.COMMAND_DOWN,
                             TokenType.COMMAND_LEFT, TokenType.COMMAND_RIGHT,
                             TokenType.COMMAND_PENUP, TokenType.COMMAND_PENDOWN,
                             TokenType.KEYWORD_REPEAT, TokenType.KEYWORD_IF,
                             TokenType.KEYWORD_WHILE)) {
                var stmt = statementParser.parse(context);
                stmtList.addStatement(stmt);
            } else {
                break; // No m√°s statements v√°lidos
            }
        }

        return stmtList;
    }
}</code></pre>

                    <h3>üîÑ Patr√≥n de Parsing en Bucle</h3>
                    <div class="loop-explanation">
                        <h4>¬øC√≥mo funciona el bucle while?</h4>

                        <div class="loop-steps">
                            <div class="step">
                                <span class="step-num">1</span>
                                <div class="step-content">
                                    <strong>Parsear el primero obligatoriamente</strong>
                                    <p>Una lista NO puede estar vac√≠a. Debe tener al menos un statement.</p>
                                </div>
                            </div>

                            <div class="step">
                                <span class="step-num">2</span>
                                <div class="step-content">
                                    <strong>Verificar condiciones de terminaci√≥n</strong>
                                    <p><code>!context.isAtEnd()</code> ‚Üí No llegamos al final del archivo</p>
                                    <p><code>!context.check(RBRACE)</code> ‚Üí No encontramos un '}'</p>
                                </div>
                            </div>

                            <div class="step">
                                <span class="step-num">3</span>
                                <div class="step-content">
                                    <strong>Verificar si viene un statement v√°lido</strong>
                                    <p>Lookahead para ver si el siguiente token inicia un statement</p>
                                </div>
                            </div>

                            <div class="step">
                                <span class="step-num">4</span>
                                <div class="step-content">
                                    <strong>Parsear y agregar a la lista</strong>
                                    <p>Delegar a StatementParser y agregar resultado</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h3>üìã Ejemplos de Parsing</h3>
                    <div class="parsing-examples">
                        <div class="example">
                            <h4>Lista simple (3 statements):</h4>
<pre><code>UP;
RIGHT;
PENDOWN;</code></pre>
                            <p><strong>Resultado:</strong> StatementListNode con 3 SimpleCommandNode</p>
                        </div>

                        <div class="example">
                            <h4>Lista mixta (statements + estructuras de control):</h4>
<pre><code>PENUP;
IF (BATTERY > 20) { UP; }
REPEAT 3 { RIGHT; }
PENDOWN;</code></pre>
                            <p><strong>Resultado:</strong> StatementListNode con 4 nodos (2 comandos + IF + REPEAT)</p>
                        </div>
                    </div>

                    <h3>‚ö†Ô∏è Condiciones de Terminaci√≥n</h3>
                    <div class="termination-conditions">
                        <p>La lista de statements termina cuando:</p>
                        <ul>
                            <li>‚úÖ Encontramos <code>}</code> (fin de bloque)</li>
                            <li>‚úÖ Llegamos a EOF (fin de archivo)</li>
                            <li>‚úÖ El siguiente token NO es inicio de statement v√°lido</li>
                        </ul>

                        <div class="warning-box">
                            ‚ö†Ô∏è <strong>Importante:</strong> NO consumimos el '}' ni el EOF aqu√≠.
                            Eso lo hace el parser que llam√≥ a StatementListParser.
                        </div>
                    </div>
                </div>
            </section>

            <!-- Manejo de Precedencia -->
            <section class="content-section">
                <h2>‚öñÔ∏è Manejo de Precedencia en Parsers</h2>
                <p class="section-intro">
                    La precedencia de operadores determina el orden de evaluaci√≥n de las expresiones. 
                    Sin un manejo correcto, <code>BATTERY > 20 AND LIGHT > 30</code> podr√≠a interpretarse 
                    incorrectamente. Los parsers resuelven esto con una arquitectura en capas.
                </p>

                <div class="precedence-problem">
                    <h3>ü§î ¬øPor qu√© necesitamos precedencia?</h3>
                    <div class="problem-example">
                        <div class="problem-case">
                            <h4>‚ùå Sin precedencia (INCORRECTO):</h4>
                            <div class="expression-breakdown">
                                <code>BATTERY > 20 AND LIGHT > 30</code>
                                <p>Podr√≠a interpretarse como:</p>
                                <code>BATTERY > (20 AND LIGHT) > 30</code>
                                <p class="error-msg">¬°Esto no tiene sentido! AND est√° operando con n√∫meros</p>
                            </div>
                        </div>
                        
                        <div class="problem-case">
                            <h4>‚úÖ Con precedencia (CORRECTO):</h4>
                            <div class="expression-breakdown">
                                <code>BATTERY > 20 AND LIGHT > 30</code>
                                <p>Se interpreta como:</p>
                                <code>(BATTERY > 20) AND (LIGHT > 30)</code>
                                <p class="success-msg">¬°Perfecto! Primero comparaciones, luego AND</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-hierarchy">
                    <h3>üìä Jerarqu√≠a de Precedencia (de MAYOR a menor)</h3>
                    <div class="precedence-tower">
                        <div class="precedence-level highest">
                            <div class="level-number">1</div>
                            <div class="level-content">
                                <strong>Comparaciones (>, <, ==, !=, >=, <=)</strong>
                                <p><strong>MAYOR precedencia</strong> - Se eval√∫an primero</p>
                                <div class="level-examples">
                                    <code>BATTERY > 20</code><br>
                                    <code>TEMP <= 100</code><br>
                                    <code>LIGHT == 50</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="precedence-level high">
                            <div class="level-number">2</div>
                            <div class="level-content">
                                <strong>NOT (!)</strong>
                                <p>Operador unario de negaci√≥n</p>
                                <div class="level-examples">
                                    <code>NOT OBSTACLE</code><br>
                                    <code>NOT (BATTERY > 50)</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="precedence-level medium">
                            <div class="level-number">3</div>
                            <div class="level-content">
                                <strong>AND (&&)</strong>
                                <p>Conjunci√≥n l√≥gica</p>
                                <div class="level-examples">
                                    <code>(BATTERY > 20) AND NOT OBSTACLE</code><br>
                                    <code>(TEMP < 100) AND (LIGHT > 30)</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="precedence-level lowest">
                            <div class="level-number">4</div>
                            <div class="level-content">
                                <strong>OR (||)</strong>
                                <p><strong>MENOR precedencia</strong> - Se eval√∫a √∫ltimo</p>
                                <div class="level-examples">
                                    <code>(BATTERY > 20) OR (LIGHT > 50)</code><br>
                                    <code>OBSTACLE OR BLOCKED</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-examples">
                    <h3>üìù Ejemplos de Precedencia en Acci√≥n</h3>
                    <div class="examples-grid">
                        <div class="precedence-example">
                            <h4>Ejemplo 1: Comparaciones vs AND</h4>
                            <div class="example-input">
                                <code>BATTERY > 20 AND LIGHT > 30</code>
                            </div>
                            <div class="precedence-steps">
                                <div class="step">
                                    <span class="step-label">Paso 1:</span> Comparaciones primero (precedencia 1)
                                    <code>(BATTERY > 20) y (LIGHT > 30)</code>
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 2:</span> Luego AND (precedencia 3)
                                    <code>(BATTERY > 20) AND (LIGHT > 30)</code>
                                </div>
                            </div>
                            <div class="ast-result">
                                <strong>AST resultante:</strong>
<pre>AndExpressionNode
‚îú‚îÄ‚îÄ ComparisonExpressionNode (BATTERY > 20)
‚îî‚îÄ‚îÄ ComparisonExpressionNode (LIGHT > 30)</pre>
                            </div>
                        </div>
                        
                        <div class="precedence-example">
                            <h4>Ejemplo 2: NOT vs AND vs OR</h4>
                            <div class="example-input">
                                <code>NOT OBSTACLE AND BATTERY > 20 OR LIGHT > 50</code>
                            </div>
                            <div class="precedence-steps">
                                <div class="step">
                                    <span class="step-label">Paso 1:</span> Comparaciones (BATTERY > 20, LIGHT > 50)
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 2:</span> NOT OBSTACLE (precedencia 2)
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 3:</span> AND (precedencia 3)
                                    <code>(NOT OBSTACLE) AND (BATTERY > 20)</code>
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 4:</span> OR (precedencia 4 - menor)
                                    <code>[(NOT OBSTACLE) AND (BATTERY > 20)] OR (LIGHT > 50)</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-implementation">
                    <h3>üèóÔ∏è ¬øC√≥mo lo implementan los parsers?</h3>
                    <p>La clave est√° en la <strong>arquitectura en capas</strong>: cada parser maneja un nivel de precedencia 
                    y delega a parsers de mayor precedencia.</p>
                    
                    <div class="layered-architecture">
                        <h4>üè¢ Arquitectura de Capas (de menor a mayor precedencia):</h4>
                        <div class="layer-diagram">
                            <div class="parser-layer or-layer">
                                <strong>OrExpressionParser</strong>
                                <span class="precedence-label">Precedencia 4 (Menor)</span>
                                <p>Maneja OR, delega AND y todo lo dem√°s</p>
                            </div>
                            <div class="delegation-arrow">‚Üì Delega a</div>
                            
                            <div class="parser-layer and-layer">
                                <strong>AndExpressionParser</strong>
                                <span class="precedence-label">Precedencia 3</span>
                                <p>Maneja AND, delega NOT y comparaciones</p>
                            </div>
                            <div class="delegation-arrow">‚Üì Delega a</div>
                            
                            <div class="parser-layer not-layer">
                                <strong>NotExpressionParser</strong>
                                <span class="precedence-label">Precedencia 2</span>
                                <p>Maneja NOT, delega comparaciones</p>
                            </div>
                            <div class="delegation-arrow">‚Üì Delega a</div>
                            
                            <div class="parser-layer comparison-layer">
                                <strong>ComparisonExpressionParser</strong>
                                <span class="precedence-label">Precedencia 1 (Mayor)</span>
                                <p>Maneja comparaciones, no delega m√°s</p>
                            </div>
                        </div>
                    </div>

                    <div class="implementation-code">
                        <h4>üíª Implementaci√≥n del Patr√≥n:</h4>
                        <div class="code-explanation">
                            <p><strong>Regla clave:</strong> Los parsers de menor precedencia llaman a parsers de mayor precedencia</p>
                        </div>
                        
<pre><code class="language-java">// OrExpressionParser - MENOR precedencia (4)
public class OrExpressionParser implements Parser&lt;ExpressionNode&gt; {
    private AndExpressionParser andParser = new AndExpressionParser(); // Delega a mayor precedencia
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        ExpressionNode left = andParser.parse(context); // Primero resuelve AND y todo lo de mayor precedencia
        
        // Luego maneja sus propios OR (si los hay)
        while (context.match(TokenType.OR)) {
            ExpressionNode right = andParser.parse(context); // Cada operando tambi√©n resuelve mayor precedencia
            left = new OrExpressionNode(left, right);
        }
        return left;
    }
}

// AndExpressionParser - Precedencia media (3)
public class AndExpressionParser implements Parser&lt;ExpressionNode&gt; {
    private NotExpressionParser notParser = new NotExpressionParser(); // Delega a mayor precedencia
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        ExpressionNode left = notParser.parse(context); // Primero resuelve NOT y comparaciones
        
        // Luego maneja sus propios AND
        while (context.match(TokenType.AND)) {
            ExpressionNode right = notParser.parse(context);
            left = new AndExpressionNode(left, right);
        }
        return left;
    }
}

// NotExpressionParser - Precedencia alta (2)
public class NotExpressionParser implements Parser&lt;ExpressionNode&gt; {
    private ComparisonExpressionParser comparisonParser = new ComparisonExpressionParser();
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        if (context.match(TokenType.NOT)) {
            // NOT tiene precedencia alta, pero a√∫n delega las comparaciones
            ExpressionNode operand = parse(context); // Recursivo para manejar NOT NOT etc.
            return new NotExpressionNode(operand);
        } else {
            // Si no hay NOT, delega a comparaciones (mayor precedencia)
            return comparisonParser.parse(context);
        }
    }
}

// ComparisonExpressionParser - MAYOR precedencia (1)
public class ComparisonExpressionParser implements Parser&lt;ExpressionNode&gt; {
    // Este NO delega a nadie para operadores, es el de mayor precedencia
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        ValueNode left = valueParser.parse(context); // Solo delega valores b√°sicos
        
        if (context.match(TokenType.GT, TokenType.LT, TokenType.EQ, /*etc*/)) {
            Token operator = context.getPreviousToken();
            ValueNode right = valueParser.parse(context);
            return new ComparisonExpressionNode(left, operator, right);
        }
        
        return left; // Si no hay comparaci√≥n, retorna el valor
    }
}</code></pre>
                    </div>
                </div>

                <div class="precedence-flow">
                    <h3>üîÑ Flujo de Ejecuci√≥n: ¬øC√≥mo funciona?</h3>
                    <p>Veamos qu√© pasa cuando parseamos <code>NOT OBSTACLE AND BATTERY > 20</code>:</p>
                    
                    <div class="execution-flow">
                        <div class="flow-step">
                            <span class="step-num">1</span>
                            <div class="step-detail">
                                <strong>OrExpressionParser.parse()</strong>
                                <p>No ve OR, delega a AND</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">2</span>
                            <div class="step-detail">
                                <strong>AndExpressionParser.parse()</strong>
                                <p>Ve AND en el medio, pero primero resuelve el lado izquierdo</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">3</span>
                            <div class="step-detail">
                                <strong>NotExpressionParser.parse()</strong>
                                <p>Ve NOT, delega OBSTACLE a comparaciones</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">4</span>
                            <div class="step-detail">
                                <strong>ComparisonExpressionParser.parse()</strong>
                                <p>OBSTACLE no es comparaci√≥n, retorna como valor</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">5</span>
                            <div class="step-detail">
                                <strong>Vuelta a NOT</strong>
                                <p>Crea NotExpressionNode(OBSTACLE)</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">6</span>
                            <div class="step-detail">
                                <strong>Vuelta a AND</strong>
                                <p>Ahora resuelve lado derecho: BATTERY > 20</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">7</span>
                            <div class="step-detail">
                                <strong>Resultado Final</strong>
                                <p>AndExpressionNode(NOT OBSTACLE, BATTERY > 20)</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-benefits">
                    <h3>üéØ ¬øPor qu√© funciona esta arquitectura?</h3>
                    <div class="benefits-explanation">
                        <div class="benefit-point">
                            <h4>üîÑ Recursi√≥n Natural</h4>
                            <p>Los parsers de menor precedencia "consumen" primero los de mayor precedencia, 
                            asegurando que las operaciones de alta precedencia se eval√∫en primero.</p>
                        </div>
                        
                        <div class="benefit-point">
                            <h4>üèóÔ∏è Asociatividad Izquierda</h4>
                            <p>El patr√≥n <code>while</code> en cada parser maneja naturalmente la asociatividad izquierda:
                            <code>A AND B AND C</code> se convierte en <code>((A AND B) AND C)</code></p>
                        </div>
                        
                        <div class="benefit-point">
                            <h4>üìù Mantenibilidad</h4>
                            <p>Cada parser solo se preocupa de SU operador. Agregar nuevos operadores es f√°cil: 
                            solo creas un nuevo parser en el nivel de precedencia correcto.</p>
                        </div>
                        
                        <div class="benefit-point">
                            <h4>üéØ Correcci√≥n</h4>
                            <p>Imposible malinterpretar precedencia: la arquitectura garantiza el orden correcto.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Mini-Ejercicios Interactivos -->
            <section class="content-section">
                <h2>üéÆ Mini-Ejercicios Interactivos</h2>
                <p class="section-intro">
                    Practica completando c√≥digo y encontrando errores comunes en parsers.
                </p>

                <div class="exercises">
                    <div class="exercise-card">
                        <h3>Ejercicio 1: Completar BooleanParser</h3>
                        <p>Completa el c√≥digo faltante:</p>
<pre><code class="language-java">public class BooleanParser implements Parser&lt;BooleanNode&gt; {
    public BooleanNode parse(ParseContext context) {
        Token token = context.getCurrentToken();
        
        if (token.getType() == TokenType.TRUE) {
            _______;  // ¬øQu√© falta aqu√≠?
            return new BooleanNode(true);
        } else if (token.getType() == TokenType.FALSE) {
            _______;  // ¬øY aqu√≠?
            return new BooleanNode(false);
        }
        
        throw new ParseException("Se esperaba true o false", token);
    }
}</code></pre>
                        <details>
                            <summary>Ver Soluci√≥n</summary>
                            <p><strong>Respuesta:</strong> <code>context.advance();</code></p>
                            <p>Es crucial avanzar despu√©s de consumir cada token.</p>
                        </details>
                    </div>

                    <div class="exercise-card">
                        <h3>Ejercicio 2: Encontrar el Error</h3>
                        <p>¬øQu√© est√° mal en este parser?</p>
<pre><code class="language-java">public class PenCommandParser implements Parser&lt;PenCommandNode&gt; {
    public PenCommandNode parse(ParseContext context) {
        Token token = context.getCurrentToken();
        
        if (context.match(TokenType.PENUP)) {
            return new PenCommandNode(token.getValue());
        } else if (context.match(TokenType.PENDOWN)) {
            return new PenCommandNode(token.getValue());
        }
        
        throw new ParseException("Se esperaba PENUP o PENDOWN", token);
    }
}</code></pre>
                        <details>
                            <summary>Ver Soluci√≥n</summary>
                            <p><strong>Error:</strong> El token se guarda ANTES del match(), no despu√©s.</p>
                            <p>match() consume el token, as√≠ que token.getValue() ya no es v√°lido.</p>
                            <p><strong>Soluci√≥n:</strong> Guardar el valor antes del match() o usar check() + advance().</p>
                        </details>
                    </div>
                </div>
            </section>

            <!-- Errores Comunes de Estudiantes -->
            <section class="content-section">
                <h2>‚ö†Ô∏è Errores Comunes de Estudiantes</h2>
                
                <div class="common-errors">
                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">üî¥</span>
                            <h3>Error #1: Token ya consumido</h3>
                        </div>
                        <div class="error-content">
                            <h4>C√≥digo Incorrecto:</h4>
<pre><code class="wrong">context.advance();
Token token = context.getCurrentToken();
// token ahora es el SIGUIENTE, no el que quer√≠as</code></pre>
                            <h4>C√≥digo Correcto:</h4>
<pre><code class="correct">Token token = context.getCurrentToken();
context.advance();
// Primero obtener, luego avanzar</code></pre>
                        </div>
                    </div>

                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">üî¥</span>
                            <h3>Error #2: Olvidar advance()</h3>
                        </div>
                        <div class="error-content">
                            <h4>S√≠ntoma:</h4>
                            <p>El parser entra en bucle infinito o se atasca</p>
                            <h4>Causa:</h4>
<pre><code class="wrong">if (token.getType() == TokenType.NUMBER) {
    // Falta context.advance() aqu√≠!
    return new NumberNode(value);
}</code></pre>
                            <h4>Regla de Oro:</h4>
                            <p>Cada token procesado debe ser consumido con advance() o match()</p>
                        </div>
                    </div>

                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">üî¥</span>
                            <h3>Error #3: Manejo incorrecto de errores</h3>
                        </div>
                        <div class="error-content">
                            <h4>C√≥digo Problem√°tico:</h4>
<pre><code class="wrong">// Mensaje gen√©rico sin contexto
throw new ParseException("Error");</code></pre>
                            <h4>Mejor Pr√°ctica:</h4>
<pre><code class="correct">throw new ParseException(
    String.format("Se esperaba %s pero se encontr√≥ %s en l√≠nea %d",
        esperado, token.getType(), token.getLine()),
    token
);</code></pre>
                        </div>
                    </div>

                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">üî¥</span>
                            <h3>Error #4: Confundir match() con check()</h3>
                        </div>
                        <div class="error-content">
                            <table class="comparison-table">
                                <tr>
                                    <th>M√©todo</th>
                                    <th>Consume Token</th>
                                    <th>Uso</th>
                                </tr>
                                <tr>
                                    <td><code>match()</code></td>
                                    <td>‚úÖ S√≠</td>
                                    <td>Cuando quieres procesar el token</td>
                                </tr>
                                <tr>
                                    <td><code>check()</code></td>
                                    <td>‚ùå No</td>
                                    <td>Cuando solo quieres mirar sin consumir</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Navegaci√≥n -->
            <section class="navigation-section">
                <div class="nav-card completed">
                    <h3>‚úÖ Has completado: Parsers - Construcci√≥n y Funcionamiento</h3>
                    <p>
                        Ahora entiendes c√≥mo se construyen los parsers desde los m√°s simples 
                        hasta los m√°s complejos. El siguiente paso es aprender a testearlos.
                    </p>
                </div>
                <div class="nav-actions">
                    <a href="ast.html" class="btn btn-secondary">‚Üê AST</a>
                    <a href="testing.html" class="btn btn-primary">
                        Siguiente: Testing
                        <span class="btn-arrow">‚Üí</span>
                    </a>
                </div>
            </section>
        </div>
    </main>

    <script src="js/script.js"></script>
    <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>