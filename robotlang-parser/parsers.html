<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parsers - Construcción y Funcionamiento | RoboLang Parser</title>
    <meta name="description" content="Aprende cómo se construyen los parsers paso a paso, desde los más simples hasta los más complejos">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/parser-implementation.css">
    <!-- Prism.js CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <header class="section-header">
        <nav class="section-nav">
            <div class="nav-content">
                <a href="index.html" class="nav-home">🏠 Inicio</a>
                <div class="nav-sections">
                    <a href="ast.html" class="nav-item">🏗️ AST</a>
                    <a href="parsers.html" class="nav-item active">⚙️ Parsers</a>
                    <a href="main-parser.html" class="nav-item">🎯 Parser Principal</a>
                    <a href="testing.html" class="nav-item">🧪 Testing</a>
                    <a href="gui.html" class="nav-item">🎨 GUI</a>
                    <a href="implementation.html" class="nav-item">🎯 Implementación</a>
                </div>
            </div>
        </nav>
        <div class="section-title">
            <h1>⚙️ Parsers - Construcción y Funcionamiento</h1>
            <p class="section-subtitle">Enseñar cómo se construyen los parsers paso a paso</p>
        </div>
    </header>

    <main class="section-content">
        <div class="content-container">
            
            <!-- Parsers 101 - Conceptos Básicos -->
            <section class="content-section">
                <h2>📚 Parsers 101 - Conceptos Básicos</h2>
                <p class="section-intro">
                    Un parser es el componente que transforma una secuencia de tokens en un 
                    Árbol de Sintaxis Abstracta (AST), validando que la entrada cumpla con las reglas gramáticas del lenguaje.
                </p>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h3>🎯 ¿Qué hace un Parser?</h3>
                        <p>
                            El parser toma los tokens generados por el lexer y los organiza en una estructura 
                            jerárquica que refleja la sintaxis del programa.
                        </p>
                        <div class="parser-flow">
                            <div class="flow-item">Tokens</div>
                            <span>→</span>
                            <div class="flow-item highlight">Parser</div>
                            <span>→</span>
                            <div class="flow-item">AST</div>
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>🏗️ Interface Parser&lt;T&gt; - El Contrato Universal</h3>
                        <p>
                            Todos nuestros parsers implementan una interface común que garantiza 
                            consistencia y permite composición entre parsers.
                        </p>
                        <div class="code-example">
<pre><code class="language-java">public interface Parser&lt;T&gt; {
    T parse(ParseContext context) throws ParseException;
}</code></pre>
                        </div>
                        
                        <div class="interface-explanation">
                            <h4>🔍 Desglose de la Interface:</h4>
                            <div class="explanation-grid">
                                <div class="explanation-item">
                                    <h5>&lt;T&gt; - Genérico de Tipo</h5>
                                    <p><strong>¿Por qué genérico?</strong> Permite que cada parser retorne su tipo específico de nodo AST:</p>
                                    <ul>
                                        <li><code>Parser&lt;NumberNode&gt;</code> → retorna NumberNode</li>
                                        <li><code>Parser&lt;IfStatementNode&gt;</code> → retorna IfStatementNode</li>
                                        <li><code>Parser&lt;ExpressionNode&gt;</code> → retorna cualquier expresión</li>
                                    </ul>
                                </div>
                                
                                <div class="explanation-item">
                                    <h5>parse(ParseContext context)</h5>
                                    <p><strong>¿Qué recibe?</strong> Un contexto que mantiene el estado del parsing:</p>
                                    <ul>
                                        <li><code>context</code>: Posición actual en los tokens</li>
                                        <li>Métodos para navegar: <code>getCurrentToken()</code>, <code>advance()</code></li>
                                        <li>Métodos para consumir: <code>match()</code>, <code>consume()</code></li>
                                    </ul>
                                </div>
                                
                                <div class="explanation-item">
                                    <h5>throws ParseException</h5>
                                    <p><strong>¿Cuándo falla?</strong> Si encuentra sintaxis inválida:</p>
                                    <ul>
                                        <li>Token inesperado: esperaba NUMBER, encontró IF</li>
                                        <li>Fin prematuro: esperaba ), llegó EOF</li>
                                        <li>Secuencia inválida: dos números seguidos</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        
                        <div class="interface-benefits">
                            <h4>🎯 Beneficios de esta Interface:</h4>
                            <div class="benefits-list">
                                <div class="benefit">
                                    <strong>1. Uniformidad:</strong> Todos los parsers "se ven" igual desde afuera
                                </div>
                                <div class="benefit">
                                    <strong>2. Composición:</strong> Un parser puede usar otro parser sin conocer los detalles internos
                                </div>
                                <div class="benefit">
                                    <strong>3. Testing:</strong> Fácil crear mocks y tests unitarios
                                </div>
                                <div class="benefit">
                                    <strong>4. Polimorfismo:</strong> Tratar diferentes parsers de manera uniforme
                                </div>
                            </div>
                        </div>
                        
                        <div class="interface-examples">
                            <h4>💻 Ejemplos de Implementación:</h4>
                            <div class="code-comparison">
                                <div class="code-version">
                                    <h5>Parser Simple:</h5>
<pre><code class="language-java">public class NumberParser implements Parser&lt;NumberNode&gt; {
    @Override
    public NumberNode parse(ParseContext context) 
            throws ParseException {
        // Implementación específica para números
        Token token = context.getCurrentToken();
        if (token.getType() == TokenType.NUMBER) {
            context.advance();
            return new NumberNode(Integer.parseInt(token.getValue()));
        }
        throw new ParseException("Expected number", token);
    }
}</code></pre>
                                </div>
                                
                                <div class="code-version">
                                    <h5>Parser Compuesto:</h5>
<pre><code class="language-java">public class ComparisonParser implements Parser&lt;ComparisonNode&gt; {
    private Parser&lt;ValueNode&gt; valueParser = new ValueParser();
    private Parser&lt;OperatorNode&gt; operatorParser = new OperatorParser();
    
    @Override
    public ComparisonNode parse(ParseContext context) 
            throws ParseException {
        // Usa otros parsers para construir la comparación
        ValueNode left = valueParser.parse(context);
        OperatorNode op = operatorParser.parse(context);
        ValueNode right = valueParser.parse(context);
        return new ComparisonNode(left, op, right);
    }
}</code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="interface-pattern">
                            <h4>🎨 Patrón de Diseño Aplicado:</h4>
                            <p>Esta interface implementa el patrón <strong>Template Method</strong>:</p>
                            <ul>
                                <li><strong>Estructura común:</strong> Todos reciben ParseContext y retornan AST</li>
                                <li><strong>Implementación específica:</strong> Cada parser decide cómo procesar su gramática</li>
                                <li><strong>Manejo de errores uniforme:</strong> Todos usan ParseException</li>
                            </ul>
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>🎨 Patrón Template Method</h3>
                        <p>
                            Los parsers siguen un patrón común: verificar token actual, 
                            consumir si coincide, construir nodo AST, y retornar resultado.
                        </p>
                        <div class="pattern-steps">
                            <ol>
                                <li>🔍 Examinar token actual</li>
                                <li>✅ Validar tipo esperado</li>
                                <li>📥 Consumir token(s)</li>
                                <li>🌳 Construir nodo AST</li>
                                <li>↩️ Retornar resultado</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ParseContext - El Corazón del Parser -->
            <section class="content-section">
                <h2>💓 ParseContext - El Corazón del Parser</h2>
                <p class="section-intro">
                    ParseContext es la clase central que gestiona el estado del parsing. 
                    Mantiene la posición actual en la lista de tokens y proporciona métodos 
                    útiles para navegar y consumir tokens.
                </p>

                <div class="context-methods">
                    <h3>🛠️ Métodos Principales de ParseContext</h3>
                    
                    <div class="method-card">
                        <div class="method-header">
                            <code>Token getCurrentToken()</code>
                            <span class="method-type">Espiar</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Obtiene el token actual <strong>sin consumirlo</strong>. 
                                Útil para decidir qué parser usar o verificar el siguiente elemento.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Ver qué viene sin avanzar
Token token = context.getCurrentToken();
if (token.getType() == TokenType.IF) {
    // Es un IF statement
    return ifStatementParser.parse(context);
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>void advance()</code>
                            <span class="method-type">Avanzar</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Avanza al siguiente token en la secuencia. 
                                <strong>Fundamental</strong> después de procesar un token.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Consumir un número
Token token = context.getCurrentToken();
int value = Integer.parseInt(token.getValue());
context.advance(); // ¡No olvidar avanzar!
return new NumberNode(value);</code></pre>
                            </div>
                            <div class="warning-box">
                                ⚠️ <strong>Error Común:</strong> Olvidar llamar advance() causa bucles infinitos
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>boolean match(TokenType... types)</code>
                            <span class="method-type">Verificar y Consumir</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica si el token actual es de alguno de los tipos especificados.
                                Si coincide, <strong>consume el token automáticamente</strong> y retorna true.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Manejar múltiples opciones
if (context.match(TokenType.UP, TokenType.DOWN, 
                   TokenType.LEFT, TokenType.RIGHT)) {
    String direction = previousToken.getValue();
    return new MovementCommandNode(direction);
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>void consume(TokenType type, String message)</code>
                            <span class="method-type">Consumir Obligatorio</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica que el token actual sea del tipo esperado y lo consume.
                                Si no coincide, lanza <strong>ParseException</strong> con el mensaje.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Requerir paréntesis
context.consume(TokenType.LPAREN, 
    "Se esperaba '(' después de IF");
// Si no hay LPAREN, lanza excepción</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>boolean check(TokenType type)</code>
                            <span class="method-type">Solo Verificar</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica si el token actual es del tipo especificado 
                                <strong>sin consumirlo</strong>. Útil para lookahead.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Verificar sin consumir
if (context.check(TokenType.ELSE)) {
    // Hay un ELSE, pero no lo consumimos aún
    // Otro parser se encargará
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="method-card">
                        <div class="method-header">
                            <code>boolean isAtEnd()</code>
                            <span class="method-type">Detectar Fin</span>
                        </div>
                        <div class="method-description">
                            <p>
                                Verifica si hemos llegado al final de la entrada (EOF).
                                Importante para evitar accesos fuera de límites.
                            </p>
                            <div class="method-example">
<pre><code class="language-java">// Ejemplo: Parsear lista de statements
List&lt;StatementNode&gt; statements = new ArrayList&lt;&gt;();
while (!context.isAtEnd() && 
       !context.check(TokenType.RBRACE)) {
    statements.add(statementParser.parse(context));
}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Parser Más Simple - NumberParser -->
            <section class="content-section">
                <h2>🔢 Parser Más Simple - NumberParser</h2>
                <p class="section-intro">
                    Comenzamos con el parser más básico: NumberParser. Este parser reconoce 
                    números enteros y los convierte en nodos NumberNode del AST.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>📝 Gramática:</strong> 
                            <code>&lt;number&gt; ::= [0-9]+</code>
                        </div>
                        <div class="bnf-visual">
                            <a href="robotlangbnf.html#number" target="_blank" class="bnf-link">
                                📖 Ver diagrama visual de number
                            </a>
                        </div>
                    </div>

                    <h3>💻 Implementación Completa</h3>
                    <div class="code-walkthrough">
<pre><code class="numbered">public class NumberParser implements Parser&lt;NumberNode&gt; {
    
    @Override
    public NumberNode parse(ParseContext context) 
            throws ParseException {
        
        // 1️⃣ Obtener el token actual
        Token token = context.getCurrentToken();
        
        // 2️⃣ Verificar que sea un NUMBER
        if (token.getType() != TokenType.NUMBER) {
            throw new ParseException(
                "Se esperaba un número, pero se encontró: " + 
                token.getType(), token
            );
        }
        
        // 3️⃣ Extraer el valor numérico
        int value = Integer.parseInt(token.getValue());
        
        // 4️⃣ IMPORTANTE: Avanzar al siguiente token
        context.advance();
        
        // 5️⃣ Crear y retornar el nodo AST
        return new NumberNode(value);
    }
}</code></pre>
                    </div>

                    <h3>📋 Explicación Línea por Línea</h3>
                    <div class="line-explanation">
                        <div class="explanation-item">
                            <span class="line-number">Línea 7:</span>
                            <p>Obtenemos el token actual sin consumirlo. Este es nuestro candidato a número.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">Línea 10:</span>
                            <p>Validación crítica: ¿Es realmente un token NUMBER? Si no, error de sintaxis.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">Línea 17:</span>
                            <p>Convertimos el string del token a entero. Asumimos que el lexer validó el formato.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">Línea 20:</span>
                            <p><strong>CRUCIAL:</strong> Avanzamos al siguiente token. Sin esto, el parser se atascará.</p>
                        </div>
                        <div class="explanation-item">
                            <span class="line-number">Línea 23:</span>
                            <p>Creamos el nodo AST con el valor parseado y lo retornamos.</p>
                        </div>
                    </div>

                    <h3>🔍 Casos de Prueba</h3>
                    <div class="test-cases">
                        <div class="test-case success">
                            <h4>✅ Caso Válido</h4>
<pre><code class="language-java">Entrada: "42"
Tokens: [NUMBER("42"), EOF]
Resultado: NumberNode(value=42)
Token después: EOF</code></pre>
                        </div>
                        <div class="test-case error">
                            <h4>❌ Caso Inválido</h4>
<pre><code class="language-java">Entrada: "UP"
Tokens: [UP, EOF]
Resultado: ParseException
Mensaje: "Se esperaba un número, pero se encontró: UP"</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Parser Intermedio - MovementCommandParser -->
            <section class="content-section">
                <h2>🚀 Parser Intermedio - MovementCommandParser</h2>
                <p class="section-intro">
                    MovementCommandParser maneja múltiples opciones de comandos de movimiento.
                    Introduce el concepto de parsear una de varias alternativas.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>📝 Gramática:</strong> 
                            <code>&lt;movement_command&gt; ::= "UP" | "DOWN" | "LEFT" | "RIGHT"</code>
                        </div>
                        <div class="bnf-visual">
                            <a href="robotlangbnf.html#movement_command" target="_blank" class="bnf-link">
                                📖 Ver diagrama visual de movement_command
                            </a>
                        </div>
                    </div>

                    <h3>💻 Implementación con match()</h3>
                    <div class="code-comparison">
                        <div class="code-version">
                            <h4>Versión Elegante con match()</h4>
<pre><code class="language-java">public class MovementCommandParser 
        implements Parser&lt;MovementCommandNode&gt; {
    
    @Override
    public MovementCommandNode parse(ParseContext context) 
            throws ParseException {
        
        // Guardamos el token antes de match()
        Token token = context.getCurrentToken();
        
        // match() verifica Y consume si coincide
        if (context.match(TokenType.UP, TokenType.DOWN,
                          TokenType.LEFT, TokenType.RIGHT)) {
            
            // Usamos el token guardado para obtener dirección
            String direction = token.getValue();
            return new MovementCommandNode(direction);
        }
        
        // Si llegamos aquí, no era un comando válido
        throw new ParseException(
            "Se esperaba comando de movimiento (UP/DOWN/LEFT/RIGHT)",
            context.getCurrentToken()
        );
    }
}</code></pre>
                        </div>

                        <div class="code-version">
                            <h4>Versión con switch/case</h4>
<pre><code class="language-java">public class MovementCommandParser 
        implements Parser&lt;MovementCommandNode&gt; {
    
    @Override
    public MovementCommandNode parse(ParseContext context) 
            throws ParseException {
        
        Token token = context.getCurrentToken();
        String direction;
        
        switch (token.getType()) {
            case UP:
                direction = "UP";
                break;
            case DOWN:
                direction = "DOWN";
                break;
            case LEFT:
                direction = "LEFT";
                break;
            case RIGHT:
                direction = "RIGHT";
                break;
            default:
                throw new ParseException(
                    "Se esperaba comando de movimiento",
                    token
                );
        }
        
        context.advance(); // No olvidar avanzar
        return new MovementCommandNode(direction);
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="comparison-note">
                        <h4>🎯 ¿Cuándo usar cada enfoque?</h4>
                        <ul>
                            <li><strong>match():</strong> Cuando todas las opciones se tratan igual</li>
                            <li><strong>switch/case:</strong> Cuando cada opción requiere lógica diferente</li>
                            <li><strong>if-else:</strong> Para condiciones complejas o anidadas</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Parser Avanzado - IfStatementParser -->
            <section class="content-section">
                <h2>🏗️ Parser Avanzado - IfStatementParser</h2>
                <p class="section-intro">
                    IfStatementParser es un parser complejo que delega a otros parsers.
                    Demuestra la composición de parsers y el manejo de estructuras anidadas.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>📝 Gramática:</strong> 
                            <code>&lt;if_stmt&gt; ::= "IF" "(" &lt;condition&gt; ")" &lt;statement_block&gt;</code>
                        </div>
                        <div class="bnf-visual">
                            <a href="robotlangbnf.html#if_statement" target="_blank" class="bnf-link">
                                📖 Ver diagrama visual de if_statement
                            </a>
                        </div>
                    </div>

                    <h3>💻 Implementación con Delegación</h3>
<pre><code class="language-java">public class IfStatementParser 
        implements Parser&lt;IfStatementNode&gt; {
    
    // Parsers que necesitamos para delegar
    private final ConditionParser conditionParser;
    private final StatementBlockParser blockParser;
    
    public IfStatementParser() {
        this.conditionParser = new ConditionParser();
        this.blockParser = new StatementBlockParser();
    }
    
    @Override
    public IfStatementNode parse(ParseContext context) 
            throws ParseException {
        
        // 1️⃣ Consumir palabra clave IF
        context.consume(TokenType.IF, 
            "Se esperaba 'IF' al inicio del statement");
        
        // 2️⃣ Consumir paréntesis izquierdo
        context.consume(TokenType.LPAREN,
            "Se esperaba '(' después de IF");
        
        // 3️⃣ DELEGAR: Parsear la condición
        ConditionNode condition = conditionParser.parse(context);
        
        // 4️⃣ Consumir paréntesis derecho
        context.consume(TokenType.RPAREN,
            "Se esperaba ')' después de la condición");
        
        // 5️⃣ DELEGAR: Parsear el bloque de statements
        StatementBlockNode thenBlock = blockParser.parse(context);
        
        // 6️⃣ Construir y retornar el nodo IF completo
        return new IfStatementNode(condition, thenBlock);
    }
}</code></pre>

                    <h3>🎨 Patrón de Delegación</h3>
                    <div class="delegation-diagram">
                        <div class="parser-flow">
                            <div class="parser-box main">
                                <strong>IfStatementParser</strong>
                                <p>Orquesta el proceso</p>
                            </div>
                            <div class="delegation-arrows">
                                <div class="arrow-down">↓ Delega</div>
                                <div class="arrow-down">↓ Delega</div>
                            </div>
                            <div class="delegated-parsers">
                                <div class="parser-box delegated">
                                    <strong>ConditionParser</strong>
                                    <p>Maneja expresiones booleanas</p>
                                </div>
                                <div class="parser-box delegated">
                                    <strong>StatementBlockParser</strong>
                                    <p>Maneja { statements }</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h3>🔄 Flujo de Ejecución</h3>
                    <div class="execution-flow">
                        <div class="flow-step">
                            <span class="step-num">1</span>
                            <div class="step-content">
                                <strong>Token: IF</strong>
                                <p>consume() verifica y avanza</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">2</span>
                            <div class="step-content">
                                <strong>Token: (</strong>
                                <p>consume() verifica y avanza</p>
                            </div>
                        </div>
                        <div class="flow-step highlight">
                            <span class="step-num">3</span>
                            <div class="step-content">
                                <strong>Tokens: BATTERY > 20</strong>
                                <p>ConditionParser toma el control</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">4</span>
                            <div class="step-content">
                                <strong>Token: )</strong>
                                <p>consume() verifica y avanza</p>
                            </div>
                        </div>
                        <div class="flow-step highlight">
                            <span class="step-num">5</span>
                            <div class="step-content">
                                <strong>Tokens: { UP; }</strong>
                                <p>StatementBlockParser toma el control</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Parser de Dispatching - StatementParser -->
            <section class="content-section">
                <h2>🎯 Parser Dispatcher - StatementParser</h2>
                <p class="section-intro">
                    StatementParser es un parser especial que actúa como **dispatcher** (despachador),
                    decidiendo qué tipo de statement parsear según el token actual.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>📝 Gramática:</strong>
                            <code>&lt;statement&gt; ::= &lt;simple_command&gt; | &lt;repeat_statement&gt; | &lt;if_statement&gt; | &lt;while_statement&gt;</code>
                        </div>
                    </div>

                    <h3>💻 Implementación Completa</h3>
<pre><code class="language-java">public class StatementParser implements Parser&lt;StatementNode&gt; {

    private SimpleCommandParser simpleCommandParser;
    private RepeatStatementParser repeatParser;
    private IfStatementParser ifParser;
    private WhileStatementParser whileParser;

    // Inicialización perezosa para evitar dependencias circulares
    private void initializeParsers() {
        if (simpleCommandParser == null) {
            simpleCommandParser = new SimpleCommandParser();
            repeatParser = new RepeatStatementParser();
            ifParser = new IfStatementParser();
            whileParser = new WhileStatementParser();
        }
    }

    @Override
    public StatementNode parse(ParseContext context) throws ParseException {
        initializeParsers();
        StatementNode stmt = new StatementNode(context.getCurrentToken());

        // 🔍 Lookahead: Verificar qué tipo de statement viene

        // Comandos simples: UP, DOWN, LEFT, RIGHT, PENUP, PENDOWN
        if (context.check(TokenType.COMMAND_UP, TokenType.COMMAND_DOWN,
                         TokenType.COMMAND_LEFT, TokenType.COMMAND_RIGHT,
                         TokenType.COMMAND_PENUP, TokenType.COMMAND_PENDOWN)) {
            var simpleCmd = simpleCommandParser.parse(context);
            stmt.setStatement(simpleCmd);
            return stmt;
        }

        // REPEAT statement
        if (context.check(TokenType.KEYWORD_REPEAT)) {
            var repeat = repeatParser.parse(context);
            stmt.setStatement(repeat);
            return stmt;
        }

        // IF statement
        if (context.check(TokenType.KEYWORD_IF)) {
            var ifStmt = ifParser.parse(context);
            stmt.setStatement(ifStmt);
            return stmt;
        }

        // WHILE statement
        if (context.check(TokenType.KEYWORD_WHILE)) {
            var whileStmt = whileParser.parse(context);
            stmt.setStatement(whileStmt);
            return stmt;
        }

        throw new ParseException("Se esperaba statement", context.getCurrentToken());
    }
}</code></pre>

                    <h3>🎨 Patrón Dispatcher</h3>
                    <div class="pattern-explanation">
                        <h4>¿Por qué usar un dispatcher?</h4>
                        <p>El StatementParser no sabe cómo parsear cada tipo de statement en detalle.
                        En su lugar, <strong>delega</strong> esa responsabilidad a parsers especializados.</p>

                        <div class="dispatcher-benefits">
                            <div class="benefit">
                                <strong>✅ Separación de responsabilidades:</strong> Cada parser se encarga de una sola cosa
                            </div>
                            <div class="benefit">
                                <strong>✅ Mantenibilidad:</strong> Cambios en un tipo de statement no afectan otros
                            </div>
                            <div class="benefit">
                                <strong>✅ Extensibilidad:</strong> Agregar nuevos statements es fácil
                            </div>
                        </div>
                    </div>

                    <h3>🔍 Lookahead Pattern</h3>
                    <p>El patrón clave aquí es el <strong>lookahead</strong> (mirar adelante sin consumir):</p>
<pre><code class="language-java">// ❌ MAL: Consumir antes de verificar
Token token = context.getCurrentToken();
context.advance(); // Ya avanzamos!
if (token.getType() == TokenType.KEYWORD_IF) {
    // Problema: ya consumimos el IF
}

// ✅ BIEN: Verificar antes de delegar
if (context.check(TokenType.KEYWORD_IF)) {
    // El parser de IF se encargará de consumir
    var ifStmt = ifParser.parse(context);
}</code></pre>
                </div>
            </section>

            <!-- Parser de Listas - StatementListParser -->
            <section class="content-section">
                <h2>📜 Parser de Listas - StatementListParser</h2>
                <p class="section-intro">
                    StatementListParser maneja secuencias de statements. Es crítico porque
                    permite que un programa tenga múltiples instrucciones.
                </p>

                <div class="parser-implementation">
                    <div class="bnf-reference">
                        <div class="bnf-inline">
                            <strong>📝 Gramática:</strong>
                            <code>&lt;statement_list&gt; ::= &lt;statement&gt; | &lt;statement&gt; &lt;statement_list&gt;</code>
                        </div>
                    </div>

                    <h3>💻 Implementación Completa</h3>
<pre><code class="language-java">public class StatementListParser implements Parser&lt;StatementListNode&gt; {

    private StatementParser statementParser;

    private void initializeParsers() {
        if (statementParser == null) {
            statementParser = new StatementParser();
        }
    }

    @Override
    public StatementListNode parse(ParseContext context) throws ParseException {
        initializeParsers();
        StatementListNode stmtList = new StatementListNode(context.getCurrentToken());

        // 1️⃣ Parsear AL MENOS un statement
        var firstStmt = statementParser.parse(context);
        stmtList.addStatement(firstStmt);

        // 2️⃣ Parsear statements adicionales mientras haya
        while (!context.isAtEnd() && !context.check(TokenType.RBRACE, TokenType.EOF)) {
            // Verificar si el siguiente token inicia un statement válido
            if (context.check(TokenType.COMMAND_UP, TokenType.COMMAND_DOWN,
                             TokenType.COMMAND_LEFT, TokenType.COMMAND_RIGHT,
                             TokenType.COMMAND_PENUP, TokenType.COMMAND_PENDOWN,
                             TokenType.KEYWORD_REPEAT, TokenType.KEYWORD_IF,
                             TokenType.KEYWORD_WHILE)) {
                var stmt = statementParser.parse(context);
                stmtList.addStatement(stmt);
            } else {
                break; // No más statements válidos
            }
        }

        return stmtList;
    }
}</code></pre>

                    <h3>🔄 Patrón de Parsing en Bucle</h3>
                    <div class="loop-explanation">
                        <h4>¿Cómo funciona el bucle while?</h4>

                        <div class="loop-steps">
                            <div class="step">
                                <span class="step-num">1</span>
                                <div class="step-content">
                                    <strong>Parsear el primero obligatoriamente</strong>
                                    <p>Una lista NO puede estar vacía. Debe tener al menos un statement.</p>
                                </div>
                            </div>

                            <div class="step">
                                <span class="step-num">2</span>
                                <div class="step-content">
                                    <strong>Verificar condiciones de terminación</strong>
                                    <p><code>!context.isAtEnd()</code> → No llegamos al final del archivo</p>
                                    <p><code>!context.check(RBRACE)</code> → No encontramos un '}'</p>
                                </div>
                            </div>

                            <div class="step">
                                <span class="step-num">3</span>
                                <div class="step-content">
                                    <strong>Verificar si viene un statement válido</strong>
                                    <p>Lookahead para ver si el siguiente token inicia un statement</p>
                                </div>
                            </div>

                            <div class="step">
                                <span class="step-num">4</span>
                                <div class="step-content">
                                    <strong>Parsear y agregar a la lista</strong>
                                    <p>Delegar a StatementParser y agregar resultado</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h3>📋 Ejemplos de Parsing</h3>
                    <div class="parsing-examples">
                        <div class="example">
                            <h4>Lista simple (3 statements):</h4>
<pre><code>UP;
RIGHT;
PENDOWN;</code></pre>
                            <p><strong>Resultado:</strong> StatementListNode con 3 SimpleCommandNode</p>
                        </div>

                        <div class="example">
                            <h4>Lista mixta (statements + estructuras de control):</h4>
<pre><code>PENUP;
IF (BATTERY > 20) { UP; }
REPEAT 3 { RIGHT; }
PENDOWN;</code></pre>
                            <p><strong>Resultado:</strong> StatementListNode con 4 nodos (2 comandos + IF + REPEAT)</p>
                        </div>
                    </div>

                    <h3>⚠️ Condiciones de Terminación</h3>
                    <div class="termination-conditions">
                        <p>La lista de statements termina cuando:</p>
                        <ul>
                            <li>✅ Encontramos <code>}</code> (fin de bloque)</li>
                            <li>✅ Llegamos a EOF (fin de archivo)</li>
                            <li>✅ El siguiente token NO es inicio de statement válido</li>
                        </ul>

                        <div class="warning-box">
                            ⚠️ <strong>Importante:</strong> NO consumimos el '}' ni el EOF aquí.
                            Eso lo hace el parser que llamó a StatementListParser.
                        </div>
                    </div>
                </div>
            </section>

            <!-- Manejo de Precedencia -->
            <section class="content-section">
                <h2>⚖️ Manejo de Precedencia en Parsers</h2>
                <p class="section-intro">
                    La precedencia de operadores determina el orden de evaluación de las expresiones. 
                    Sin un manejo correcto, <code>BATTERY > 20 AND LIGHT > 30</code> podría interpretarse 
                    incorrectamente. Los parsers resuelven esto con una arquitectura en capas.
                </p>

                <div class="precedence-problem">
                    <h3>🤔 ¿Por qué necesitamos precedencia?</h3>
                    <div class="problem-example">
                        <div class="problem-case">
                            <h4>❌ Sin precedencia (INCORRECTO):</h4>
                            <div class="expression-breakdown">
                                <code>BATTERY > 20 AND LIGHT > 30</code>
                                <p>Podría interpretarse como:</p>
                                <code>BATTERY > (20 AND LIGHT) > 30</code>
                                <p class="error-msg">¡Esto no tiene sentido! AND está operando con números</p>
                            </div>
                        </div>
                        
                        <div class="problem-case">
                            <h4>✅ Con precedencia (CORRECTO):</h4>
                            <div class="expression-breakdown">
                                <code>BATTERY > 20 AND LIGHT > 30</code>
                                <p>Se interpreta como:</p>
                                <code>(BATTERY > 20) AND (LIGHT > 30)</code>
                                <p class="success-msg">¡Perfecto! Primero comparaciones, luego AND</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-hierarchy">
                    <h3>📊 Jerarquía de Precedencia (de MAYOR a menor)</h3>
                    <div class="precedence-tower">
                        <div class="precedence-level highest">
                            <div class="level-number">1</div>
                            <div class="level-content">
                                <strong>Comparaciones (>, <, ==, !=, >=, <=)</strong>
                                <p><strong>MAYOR precedencia</strong> - Se evalúan primero</p>
                                <div class="level-examples">
                                    <code>BATTERY > 20</code><br>
                                    <code>TEMP <= 100</code><br>
                                    <code>LIGHT == 50</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="precedence-level high">
                            <div class="level-number">2</div>
                            <div class="level-content">
                                <strong>NOT (!)</strong>
                                <p>Operador unario de negación</p>
                                <div class="level-examples">
                                    <code>NOT OBSTACLE</code><br>
                                    <code>NOT (BATTERY > 50)</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="precedence-level medium">
                            <div class="level-number">3</div>
                            <div class="level-content">
                                <strong>AND (&&)</strong>
                                <p>Conjunción lógica</p>
                                <div class="level-examples">
                                    <code>(BATTERY > 20) AND NOT OBSTACLE</code><br>
                                    <code>(TEMP < 100) AND (LIGHT > 30)</code>
                                </div>
                            </div>
                        </div>
                        
                        <div class="precedence-level lowest">
                            <div class="level-number">4</div>
                            <div class="level-content">
                                <strong>OR (||)</strong>
                                <p><strong>MENOR precedencia</strong> - Se evalúa último</p>
                                <div class="level-examples">
                                    <code>(BATTERY > 20) OR (LIGHT > 50)</code><br>
                                    <code>OBSTACLE OR BLOCKED</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-examples">
                    <h3>📝 Ejemplos de Precedencia en Acción</h3>
                    <div class="examples-grid">
                        <div class="precedence-example">
                            <h4>Ejemplo 1: Comparaciones vs AND</h4>
                            <div class="example-input">
                                <code>BATTERY > 20 AND LIGHT > 30</code>
                            </div>
                            <div class="precedence-steps">
                                <div class="step">
                                    <span class="step-label">Paso 1:</span> Comparaciones primero (precedencia 1)
                                    <code>(BATTERY > 20) y (LIGHT > 30)</code>
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 2:</span> Luego AND (precedencia 3)
                                    <code>(BATTERY > 20) AND (LIGHT > 30)</code>
                                </div>
                            </div>
                            <div class="ast-result">
                                <strong>AST resultante:</strong>
<pre>AndExpressionNode
├── ComparisonExpressionNode (BATTERY > 20)
└── ComparisonExpressionNode (LIGHT > 30)</pre>
                            </div>
                        </div>
                        
                        <div class="precedence-example">
                            <h4>Ejemplo 2: NOT vs AND vs OR</h4>
                            <div class="example-input">
                                <code>NOT OBSTACLE AND BATTERY > 20 OR LIGHT > 50</code>
                            </div>
                            <div class="precedence-steps">
                                <div class="step">
                                    <span class="step-label">Paso 1:</span> Comparaciones (BATTERY > 20, LIGHT > 50)
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 2:</span> NOT OBSTACLE (precedencia 2)
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 3:</span> AND (precedencia 3)
                                    <code>(NOT OBSTACLE) AND (BATTERY > 20)</code>
                                </div>
                                <div class="step">
                                    <span class="step-label">Paso 4:</span> OR (precedencia 4 - menor)
                                    <code>[(NOT OBSTACLE) AND (BATTERY > 20)] OR (LIGHT > 50)</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-implementation">
                    <h3>🏗️ ¿Cómo lo implementan los parsers?</h3>
                    <p>La clave está en la <strong>arquitectura en capas</strong>: cada parser maneja un nivel de precedencia 
                    y delega a parsers de mayor precedencia.</p>
                    
                    <div class="layered-architecture">
                        <h4>🏢 Arquitectura de Capas (de menor a mayor precedencia):</h4>
                        <div class="layer-diagram">
                            <div class="parser-layer or-layer">
                                <strong>OrExpressionParser</strong>
                                <span class="precedence-label">Precedencia 4 (Menor)</span>
                                <p>Maneja OR, delega AND y todo lo demás</p>
                            </div>
                            <div class="delegation-arrow">↓ Delega a</div>
                            
                            <div class="parser-layer and-layer">
                                <strong>AndExpressionParser</strong>
                                <span class="precedence-label">Precedencia 3</span>
                                <p>Maneja AND, delega NOT y comparaciones</p>
                            </div>
                            <div class="delegation-arrow">↓ Delega a</div>
                            
                            <div class="parser-layer not-layer">
                                <strong>NotExpressionParser</strong>
                                <span class="precedence-label">Precedencia 2</span>
                                <p>Maneja NOT, delega comparaciones</p>
                            </div>
                            <div class="delegation-arrow">↓ Delega a</div>
                            
                            <div class="parser-layer comparison-layer">
                                <strong>ComparisonExpressionParser</strong>
                                <span class="precedence-label">Precedencia 1 (Mayor)</span>
                                <p>Maneja comparaciones, no delega más</p>
                            </div>
                        </div>
                    </div>

                    <div class="implementation-code">
                        <h4>💻 Implementación del Patrón:</h4>
                        <div class="code-explanation">
                            <p><strong>Regla clave:</strong> Los parsers de menor precedencia llaman a parsers de mayor precedencia</p>
                        </div>
                        
<pre><code class="language-java">// OrExpressionParser - MENOR precedencia (4)
public class OrExpressionParser implements Parser&lt;ExpressionNode&gt; {
    private AndExpressionParser andParser = new AndExpressionParser(); // Delega a mayor precedencia
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        ExpressionNode left = andParser.parse(context); // Primero resuelve AND y todo lo de mayor precedencia
        
        // Luego maneja sus propios OR (si los hay)
        while (context.match(TokenType.OR)) {
            ExpressionNode right = andParser.parse(context); // Cada operando también resuelve mayor precedencia
            left = new OrExpressionNode(left, right);
        }
        return left;
    }
}

// AndExpressionParser - Precedencia media (3)
public class AndExpressionParser implements Parser&lt;ExpressionNode&gt; {
    private NotExpressionParser notParser = new NotExpressionParser(); // Delega a mayor precedencia
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        ExpressionNode left = notParser.parse(context); // Primero resuelve NOT y comparaciones
        
        // Luego maneja sus propios AND
        while (context.match(TokenType.AND)) {
            ExpressionNode right = notParser.parse(context);
            left = new AndExpressionNode(left, right);
        }
        return left;
    }
}

// NotExpressionParser - Precedencia alta (2)
public class NotExpressionParser implements Parser&lt;ExpressionNode&gt; {
    private ComparisonExpressionParser comparisonParser = new ComparisonExpressionParser();
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        if (context.match(TokenType.NOT)) {
            // NOT tiene precedencia alta, pero aún delega las comparaciones
            ExpressionNode operand = parse(context); // Recursivo para manejar NOT NOT etc.
            return new NotExpressionNode(operand);
        } else {
            // Si no hay NOT, delega a comparaciones (mayor precedencia)
            return comparisonParser.parse(context);
        }
    }
}

// ComparisonExpressionParser - MAYOR precedencia (1)
public class ComparisonExpressionParser implements Parser&lt;ExpressionNode&gt; {
    // Este NO delega a nadie para operadores, es el de mayor precedencia
    
    public ExpressionNode parse(ParseContext context) throws ParseException {
        ValueNode left = valueParser.parse(context); // Solo delega valores básicos
        
        if (context.match(TokenType.GT, TokenType.LT, TokenType.EQ, /*etc*/)) {
            Token operator = context.getPreviousToken();
            ValueNode right = valueParser.parse(context);
            return new ComparisonExpressionNode(left, operator, right);
        }
        
        return left; // Si no hay comparación, retorna el valor
    }
}</code></pre>
                    </div>
                </div>

                <div class="precedence-flow">
                    <h3>🔄 Flujo de Ejecución: ¿Cómo funciona?</h3>
                    <p>Veamos qué pasa cuando parseamos <code>NOT OBSTACLE AND BATTERY > 20</code>:</p>
                    
                    <div class="execution-flow">
                        <div class="flow-step">
                            <span class="step-num">1</span>
                            <div class="step-detail">
                                <strong>OrExpressionParser.parse()</strong>
                                <p>No ve OR, delega a AND</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">2</span>
                            <div class="step-detail">
                                <strong>AndExpressionParser.parse()</strong>
                                <p>Ve AND en el medio, pero primero resuelve el lado izquierdo</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">3</span>
                            <div class="step-detail">
                                <strong>NotExpressionParser.parse()</strong>
                                <p>Ve NOT, delega OBSTACLE a comparaciones</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">4</span>
                            <div class="step-detail">
                                <strong>ComparisonExpressionParser.parse()</strong>
                                <p>OBSTACLE no es comparación, retorna como valor</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">5</span>
                            <div class="step-detail">
                                <strong>Vuelta a NOT</strong>
                                <p>Crea NotExpressionNode(OBSTACLE)</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">6</span>
                            <div class="step-detail">
                                <strong>Vuelta a AND</strong>
                                <p>Ahora resuelve lado derecho: BATTERY > 20</p>
                            </div>
                        </div>
                        <div class="flow-step">
                            <span class="step-num">7</span>
                            <div class="step-detail">
                                <strong>Resultado Final</strong>
                                <p>AndExpressionNode(NOT OBSTACLE, BATTERY > 20)</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="precedence-benefits">
                    <h3>🎯 ¿Por qué funciona esta arquitectura?</h3>
                    <div class="benefits-explanation">
                        <div class="benefit-point">
                            <h4>🔄 Recursión Natural</h4>
                            <p>Los parsers de menor precedencia "consumen" primero los de mayor precedencia, 
                            asegurando que las operaciones de alta precedencia se evalúen primero.</p>
                        </div>
                        
                        <div class="benefit-point">
                            <h4>🏗️ Asociatividad Izquierda</h4>
                            <p>El patrón <code>while</code> en cada parser maneja naturalmente la asociatividad izquierda:
                            <code>A AND B AND C</code> se convierte en <code>((A AND B) AND C)</code></p>
                        </div>
                        
                        <div class="benefit-point">
                            <h4>📝 Mantenibilidad</h4>
                            <p>Cada parser solo se preocupa de SU operador. Agregar nuevos operadores es fácil: 
                            solo creas un nuevo parser en el nivel de precedencia correcto.</p>
                        </div>
                        
                        <div class="benefit-point">
                            <h4>🎯 Corrección</h4>
                            <p>Imposible malinterpretar precedencia: la arquitectura garantiza el orden correcto.</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Mini-Ejercicios Interactivos -->
            <section class="content-section">
                <h2>🎮 Mini-Ejercicios Interactivos</h2>
                <p class="section-intro">
                    Practica completando código y encontrando errores comunes en parsers.
                </p>

                <div class="exercises">
                    <div class="exercise-card">
                        <h3>Ejercicio 1: Completar BooleanParser</h3>
                        <p>Completa el código faltante:</p>
<pre><code class="language-java">public class BooleanParser implements Parser&lt;BooleanNode&gt; {
    public BooleanNode parse(ParseContext context) {
        Token token = context.getCurrentToken();
        
        if (token.getType() == TokenType.TRUE) {
            _______;  // ¿Qué falta aquí?
            return new BooleanNode(true);
        } else if (token.getType() == TokenType.FALSE) {
            _______;  // ¿Y aquí?
            return new BooleanNode(false);
        }
        
        throw new ParseException("Se esperaba true o false", token);
    }
}</code></pre>
                        <details>
                            <summary>Ver Solución</summary>
                            <p><strong>Respuesta:</strong> <code>context.advance();</code></p>
                            <p>Es crucial avanzar después de consumir cada token.</p>
                        </details>
                    </div>

                    <div class="exercise-card">
                        <h3>Ejercicio 2: Encontrar el Error</h3>
                        <p>¿Qué está mal en este parser?</p>
<pre><code class="language-java">public class PenCommandParser implements Parser&lt;PenCommandNode&gt; {
    public PenCommandNode parse(ParseContext context) {
        Token token = context.getCurrentToken();
        
        if (context.match(TokenType.PENUP)) {
            return new PenCommandNode(token.getValue());
        } else if (context.match(TokenType.PENDOWN)) {
            return new PenCommandNode(token.getValue());
        }
        
        throw new ParseException("Se esperaba PENUP o PENDOWN", token);
    }
}</code></pre>
                        <details>
                            <summary>Ver Solución</summary>
                            <p><strong>Error:</strong> El token se guarda ANTES del match(), no después.</p>
                            <p>match() consume el token, así que token.getValue() ya no es válido.</p>
                            <p><strong>Solución:</strong> Guardar el valor antes del match() o usar check() + advance().</p>
                        </details>
                    </div>
                </div>
            </section>

            <!-- Errores Comunes de Estudiantes -->
            <section class="content-section">
                <h2>⚠️ Errores Comunes de Estudiantes</h2>
                
                <div class="common-errors">
                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">🔴</span>
                            <h3>Error #1: Token ya consumido</h3>
                        </div>
                        <div class="error-content">
                            <h4>Código Incorrecto:</h4>
<pre><code class="wrong">context.advance();
Token token = context.getCurrentToken();
// token ahora es el SIGUIENTE, no el que querías</code></pre>
                            <h4>Código Correcto:</h4>
<pre><code class="correct">Token token = context.getCurrentToken();
context.advance();
// Primero obtener, luego avanzar</code></pre>
                        </div>
                    </div>

                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">🔴</span>
                            <h3>Error #2: Olvidar advance()</h3>
                        </div>
                        <div class="error-content">
                            <h4>Síntoma:</h4>
                            <p>El parser entra en bucle infinito o se atasca</p>
                            <h4>Causa:</h4>
<pre><code class="wrong">if (token.getType() == TokenType.NUMBER) {
    // Falta context.advance() aquí!
    return new NumberNode(value);
}</code></pre>
                            <h4>Regla de Oro:</h4>
                            <p>Cada token procesado debe ser consumido con advance() o match()</p>
                        </div>
                    </div>

                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">🔴</span>
                            <h3>Error #3: Manejo incorrecto de errores</h3>
                        </div>
                        <div class="error-content">
                            <h4>Código Problemático:</h4>
<pre><code class="wrong">// Mensaje genérico sin contexto
throw new ParseException("Error");</code></pre>
                            <h4>Mejor Práctica:</h4>
<pre><code class="correct">throw new ParseException(
    String.format("Se esperaba %s pero se encontró %s en línea %d",
        esperado, token.getType(), token.getLine()),
    token
);</code></pre>
                        </div>
                    </div>

                    <div class="error-card">
                        <div class="error-header">
                            <span class="error-icon">🔴</span>
                            <h3>Error #4: Confundir match() con check()</h3>
                        </div>
                        <div class="error-content">
                            <table class="comparison-table">
                                <tr>
                                    <th>Método</th>
                                    <th>Consume Token</th>
                                    <th>Uso</th>
                                </tr>
                                <tr>
                                    <td><code>match()</code></td>
                                    <td>✅ Sí</td>
                                    <td>Cuando quieres procesar el token</td>
                                </tr>
                                <tr>
                                    <td><code>check()</code></td>
                                    <td>❌ No</td>
                                    <td>Cuando solo quieres mirar sin consumir</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Navegación -->
            <section class="navigation-section">
                <div class="nav-card completed">
                    <h3>✅ Has completado: Parsers - Construcción y Funcionamiento</h3>
                    <p>
                        Ahora entiendes cómo se construyen los parsers desde los más simples 
                        hasta los más complejos. El siguiente paso es aprender a testearlos.
                    </p>
                </div>
                <div class="nav-actions">
                    <a href="ast.html" class="btn btn-secondary">← AST</a>
                    <a href="testing.html" class="btn btn-primary">
                        Siguiente: Testing
                        <span class="btn-arrow">→</span>
                    </a>
                </div>
            </section>
        </div>
    </main>

    <script src="js/script.js"></script>
    <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>